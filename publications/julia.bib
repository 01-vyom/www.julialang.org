@inproceedings{K14,
	Abstract = {Julia is a young programming language that is designed for technical computing. Although Julia is dynamically typed it is very fast and usually yields C speed by utilizing a just-in-time compiler. Still, Julia has a simple syntax that is similar to Matlab, which is widely known as an easy-to-use programming environment. While Julia is very versatile and provides asynchronous programming facilities in the form of tasks (coroutines) as well as distributed multi-process parallelism, one missing feature is shared memory multi-threading. In this paper we present our experiment on introducing multi-threading support in the Julia programming environment. While our implementation has some restrictions that have to be taken into account when using threads, the results are promising yielding almost full speedup for perfectly parallelizable tasks.},
	Address = {New York},
	Author = {Tobias Knopp},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.11},
	Pages = {1-5},
	Publisher = {{ACM}},
	Title = {Experimental Multi-threading Support for the {J}ulia Programming Language},
	Year = {2014},
}

@inproceedings{UMZHDB14,
	Abstract = {This paper describes Convex, a convex optimization modeling framework in Julia. Convex translates problems from a user-friendly functional language into an abstract syntax tree describing the problem. This concise representation of the global structure of the problem allows Convex to infer whether the problem complies with the rules of disciplined convex programming (DCP), and to pass the problem to a suitable solver. These operations are carried out in Julia using multiple dispatch, which dramatically reduces the time required to verify DCP compliance and to parse a problem into conic form. Convex then automatically chooses an appropriate backend solver to solve the conic form problem.},
	Address = {New York},
	Eprinttype = {arXiv},
	Author = {Madeleine Udell and Karanveer Mohan and David Zeng and Jenny Hong and Steven Diamond and Stephen Boyd},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.5},
	Eprint = {1410.4821},
	Pages = {18-28},
	Eprintclass = {math.OC},
	Publisher = {{ACM}},
	Title = {Convex Optimization in Julia},
	Year = {2014},
}

@inproceedings{HLP14,
	Abstract = {We present scalable algebraic modeling software, StochJuMP, for stochastic optimization as applied to power grid economic dispatch. It enables the user to express the problem in a high-level algebraic format with minimal boilerplate. StochJuMP allows efficient parallel model instantiation across nodes and efficient data localization. Computational results are presented showing that the model construction is efficient, requiring less than one percent of solve time. StochJuMP is configured with the parallel interior-point solver PIPS-IPM but is sufficiently generic to allow straight forward adaptation to other solvers.  },
	Address = {New York},
	Eprinttype = {ANL},
	Author = {Joey Huchette and Miles Lubin and Cosmin Petra},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.6},
	Eprint = {MCS-P5181-0814},
	Pages = {29-35},
	Publisher = {{ACM}},
	Title = {Parallel algebraic modeling for stochastic optimization},
	Year = {2014},
}

@inproceedings{HT14,
	Abstract = {We discuss the advantages of using Julia for solving multiscale problems involving partial differential equations (PDEs). Multiscale problems are problems where the coefficients of a PDE oscillate rapidly on a microscopic length scale, but solutions are sought on a much larger, macroscopic domain. Solving multiscale problems requires both a theoretic result, i.e., a homogenization result yielding effective coefficients, as well as numerical solutions of the PDE at the microscopic and the macroscopic length scales.

Numerical homogenization of PDEs with stochastic coefficients is especially computationally expensive. Under certain assumptions, effective coefficients can be found, but their calculation involves subtle numerical problems. The computational cost is huge due to the generally large number of stochastic dimensions.

Multiscale problems arise in many applications, e.g., in uncertainty quantification, in the rational design of nanoscale sensors, and in the rational design of materials.

Our code for the numerical stochastic homogenization of elliptic problems is implemented in Julia. Since multiscale problems pose new numerical problems, it is in any case necessary to develop new numerical codes. Julia is a dynamic language inspired by the Lisp family of languages, it is open-source, and it provides native-code compilation, access to highly optimized linear-algebra routines, support for parallel computing, and a powerful macro system. We describe our experience in using Julia and discuss the advantages of Julia's features in this problem domain.},
	Address = {New York},
	Author = {Clemens Heitzinger and Gerhard Tulzer},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.8},
	Pages = {36-40},
	Publisher = {{ACM}},
	Title = {Julia and the numerical homogenization of {PDE}s},
	Year = {2014},
}

@inproceedings{CE14,
	Abstract = {Polymorphism in programming languages enables code reuse. Here, we show that polymorphism has broad applicability far beyond computations for technical computing: parallelism in distributed computing, presentation of visualizations of runtime data flow, and proofs for formal verification of correctness. The ability to reuse a single codebase for all these purposes provides new ways to understand and verify parallel programs.},
	Address = {New York},
	Eprinttype = {arXiv},
	Author = {Jiahao Chen and Alan Edelman},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.9},
	Eprint = {1410.6449},
	Pages = {47-56},
	Eprintclass = {cs.PL},
	Publisher = {{ACM}},
	Title = {Parallel Prefix Polymorphism Permits Parallelization, Presentation \& Proof},
	Url = {http://jiahao.github.io/parallel-prefix},
	Year = {2014},
}

@article{LD13,
	Abstract = {The state of numerical computing is currently characterized by a divide between highly efficient yet typically cumbersome low-level languages such as C, C++, and Fortran and highly expressive yet typically slow high-level languages such as Python and MATLAB. This paper explores how Julia, a modern programming language for numerical computing which claims to bridge this divide by incorporating recent advances in language and compiler design (such as just-in-time compilation), can be used for implementing software and algorithms fundamental to the field of operations research, with a focus on mathematical optimization. In particular, we demonstrate algebraic modeling for linear and nonlinear optimization and a partial implementation of a practical simplex code. Extensive cross-language benchmarks suggest that Julia is capable of obtaining state-of-the-art performance.},
	Eprinttype = {arXiv},
	Author = {Miles Lubin and Iain Dunning},
	Eprint = {1312.1431},
	Eprintclass = {math.OC},
	Title = {Computing in Operations Research using {J}ulia},
	Year = {2013}}

@inproceedings{OT14,
	Abstract = {We describe a framework for solving a broad class of infinite-dimensional linear equations, consisting of almost banded operators, which can be used to resepresent linear ordinary differential equations with general boundary conditions. The framework contains a data structure on which row operations can be performed, allowing for the solution of linear equations by the adaptive QR approach. The algorithm achieves $O(n^{opt})$ complexity, where $n^opt$ is the number of degrees of freedom required to achieve a desired accuracy, which is determined adaptively. In addition, special tensor product equations, such as partial differential equations on rectangles, can be solved by truncating the operator in the $y$-direction with $n_y$ degrees of freedom and using a generalized Schur decomposition to upper triangularize, before applying the adaptive QR approach to the $x$-direction, requiring $O(n^2_y n^{opt}_x)$ operations. The framework is implemented in the ApproxFun package written in the Julia programming language, which achieves highly competitive computational costs by exploiting unique features of Julia.},
	Address = {New York},
	Eprinttype = {arXiv},
	Author = {Sheehan Olver and Alex Townsend},
	Booktitle = {HPTCDL'14 Proceedings of the 1st Workshop on High Performance Technical Computing in Dynamic Languages},
	Doi = {10.1109/HPTCDL.2014.10},
	Eprint = {1409.5529},
	Pages = {57-62},
	Eprintclass = {math.NA},
	Publisher = {{ACM}},
	Title = {A practical framework for infinite-dimensional linear algebra},
	Year = {2014}}

@inproceedings{BCKSE14,
	Abstract = {Arrays are such a rich and fundamental data type that they tend to be built into a language, either in the compiler or in a large low-level library. Defining this functionality at the user level instead provides greater flexibility for application domains not envisioned by the language designer. Only a few languages, such as C++ and Haskell, provide the necessary power to define n-dimensional arrays, but these systems rely on compile-time abstraction, sacrificing some flexibility. In contrast, dynamic languages make it straightforward for the user to define any behavior they might want, but at the possible expense of performance. 
As part of the Julia language project, we have developed an approach that yields a novel trade-off between flexibility and compile-time analysis. The core abstraction we use is multiple dispatch. We have come to believe that while multiple dispatch has not been especially popular in most kinds of programming, technical computing is its killer application. By expressing key functions such as array indexing using multi-method signatures, a surprising range of behaviors can be obtained, in a way that is both relatively easy to write and amenable to compiler analysis. The compact factoring of concerns provided by these methods makes it easier for user-defined types to behave consistently with types in the standard library.},
	Address = {New York, {NY}, {USA}},
	Eprinttype = {arXiv},
	Author = {Jeff Bezanson and Jiahao Chen and Stefan Karpinski and Viral Shah and Alan Edelman},
	Booktitle = {ARRAY'14 Proceedings of ACM SIGPLAN International Workshop on Libraries, Languages, and Compilers for Array Programming},
	Doi = {10.1145/2627373.2627383},
	Eprint = {1407.3845},
	Pages = {56-61},
	Eprintclass = {cs.PL},
	Publisher = {{ACM}},
	Title = {Array operators using multiple dispatch: a design methodology for array implementations in dynamic languages},
	Year = {2014}}

@article{BKSE12,
	Abstract = {Dynamic languages have become popular for scientific computing. They are generally considered highly productive, but lacking in performance. This paper presents Julia, a new dynamic language for technical computing, designed for performance from the beginning by adapting and extending modern programming language techniques. A design based on generic functions and a rich type system simultaneously enables an expressive programming model and successful type inference, leading to good performance for a wide range of programs. This makes it possible for much of the Julia library to be written in Julia itself, while also incorporating best-of-breed C and Fortran libraries.},
	Eprinttype = {arXiv},
	Author = {Jeff Bezanson and Stefan Karpinski and Viral B. Shah and Alan Edelman},
	Eprint = {1209.5145},
	Month = {September},
	Eprintclass = {cs.PL},
	Title = {{J}ulia: A Fast Dynamic Language for Technical Computing},
	Year = {2012}}

@article{BEKS14,
	Abstract = {The Julia programming language is gaining enormous popularity. Julia was designed to be easy and fast. Most importantly, Julia shatters deeply established notions widely held in the applied community:

1. High-level, dynamic code has to be slow by some sort of law of nature.
2. It is sensible to prototype in one language and then recode in another language.
3. There are parts of a system for the programmer, and other parts best left untouched as they are built by the experts. 

Julia began with a deep understanding of the needs of the scientific programmer and the needs of the computer in mind. Bridging cultures that have often been distant, Julia combines expertise from computer science and computational science creating a new approach to scientific computing. This note introduces the programmer to the language and the underlying design theory. It invites the reader to rethink the fundamental foundations of numerical computing systems.

In particular, there is the fascinating dance between specialization and abstraction. Specialization allows for custom treatment. We can pick just the right algorithm for the right circumstance and this can happen at runtime based on argument types (code selection via multiple dispatch). Abstraction recognizes what remains the same after differences are stripped away and ignored as irrelevant. The recognition of abstraction allows for code reuse (generic programming). A simple idea that yields incredible power. The Julia design facilitates this interplay in many explicit and subtle ways for machine performance and, most importantly, human convenience.},
	Eprinttype = {arXiv},
	Author = {Jeff Bezanson and Alan Edelman and Stefan Karpinski and Viral B. Shah},
	Eprint = {1411.1607},
	Month = {November},
	Eprintclass = {cs.MS},
	Title = {{J}ulia: A Fresh Approach to Numerical Computing},
	Year = {2014}}

@article{SO2014,
	Abstract = {We investigate the use of conformal maps for the acceleration of convergence of the trapezoidal rule and Sinc numerical methods. The conformal map is a polynomial adjustment to the sinh map, and allows the treatment of a finite number of singularities in the complex plane. In the case where locations are unknown, the so-called Sinc-Pad\'e approximants are used to provide approximate results. This adaptive method is shown to have almost the same convergence properties. We use the conformal maps to generate high accuracy solutions to several challenging integrals, nonlinear waves, and multidimensional integrals.},
	Eprint = {1406.3320},
	Eprintclass = {math.NA},
	Eprinttype = {arXiv},
	Author = {Richard Mika\"el Slevinsky and Sheehan Olver},
	Title = {On the use of conformal maps for the acceleration of convergence of the trapezoidal rule and Sinc numerical methods},
	Year = {2014}
}

@article{TTO14,
	Abstract = {A fast and accurate algorithm for the computation of Gauss-Hermite and generalized Gauss-Hermite quadrature nodes and weights is presented. The algorithm is based on Newton's method with carefully selected initial guesses for the nodes and a fast evaluation scheme for the associated orthogonal polynomial. In the Gauss-Hermite case the initial guesses and evaluation scheme rely on explicit asymptotic formulas. For generalized Gauss-Hermite, the initial guesses are furnished by sampling a certain equilibrium measure and the associated polynomial evaluated via a Riemann-Hilbert reformulation. In both cases the $n$-point quadrature rule is computed in $\mathcal{O}(n)$ operations to an accuracy that is close to machine precision. For sufficiently large n, some of the quadrature weights have a value less than the smallest positive normalized floating-point number in double precision and we exploit this fact to achieve a complexity as low as $\mathcal{O}(\sqrt{n})$.},
       Eprint = {1410.5286},
	Eprintclass = {math.NA},
 	Eprinttype = {arXiv},
	Author = {Alex Townsend and Thomas Trogdon and Sheehan Olver},
	Title = {Fast computation of {Gauss} quadrature nodes and weights on the whole real line},
	Year = {2014}
}

@article{ONT14,
	Abstract = {We develop an algorithm for sampling from the unitary invariant random matrix ensembles. The algorithm is based on the representation of their eigenvalues as a determinantal point process whose kernel is given in terms of orthogonal polynomials. Using this algorithm, statistics beyond those known through analysis are calculable through Monte Carlo simulation. Unexpected phenomena are observed in the simulations.},
	Eprint = {1404.0071},
	Eprintclass = {math-ph},
	Eprinttype = {arXiv},
	Author = {Sheehan Olver and Raj Rao Nadakuditi and Thomas Trogdon},
	Title = {Sampling unitary invariant ensembles},
	Year = {2014}
}

@article{TO14,
	Abstract = {A spectral method for solving linear partial differential equations (PDEs) with variable coefficients and general boundary conditions defined on rectangular domains is described, based on separable representations of partial differential operators and the one-dimensional ultraspherical spectral method.  If a partial differential operator is of splitting rank~$2$, such as the operator associated with Poisson or Helmholtz, the corresponding PDE is solved via a generalized Sylvester matrix equation, and a bivariate polynomial approximation of the solution of degree $(n_x,n_y)$ is computed in $\mathcal{O}((n_x n_y)^{3/2})$ operations. Partial differential operators of splitting rank~$\geq 3$ are solved via a linear system involving a block-banded matrix in $\mathcal{O}(\min(n_x^{3} n_y,n_x n_y^{3}))$ operations.  Numerical examples demonstrate the applicability of our 2D spectral method to a broad class of PDEs, which includes elliptic and dispersive time-evolution equations.  The resulting PDE solver is written in {\sc Matlab} and is publicly available as part of {\sc Chebfun}. It can resolve solutions requiring over a million degrees of freedom in under $60$ seconds. An experimental implementation in the Julia language can currently perform the same solve in $10$ seconds.},
	Eprint = {1409.2789},
	Eprintclass = {math.NA},
	Eprinttype = {arXiv},
	Author = {Alex Townsend and Sheehan Olver},
	Title = {The automatic solution of partial differential equations using a global spectral method},
	Year = {2014}
}

@article{GSS14,
	Abstract = {A quantum anharmonic oscillator is defined by the Hamiltonian ${\cal H}= -\frac{ {\rm d^{2}}}{{\rm d}x^{2}} + V(x)$, where the potential is given by $V(x) = \sum_{i=1}^{m} c_{i} x^{2i}$ with $c_{m}>0$. Using the Sinc collocation method combined with the double exponential transformation, we develop a method to efficiently compute highly accurate approximations of energy eigenvalues for anharmonic oscillators. Convergence properties of the proposed method are presented.  Using the principle of minimal sensitivity, we introduce an alternate expression for the mesh size for the Sinc collocation method which improves considerably the accuracy in computing eigenvalues for potentials with multiple wells.

We apply our method to a number of potentials including potentials with multiple wells. The numerical results section clearly illustrates the high efficiency and accuracy of the proposed method. All our codes are written using the programming language Julia and are available upon request.}
	Eprint = {1411.2089},
	Eprintclass = {math.NA},
	Eprinttype = {arXiv},
	Author = {Philippe Gaudreau and Richard Slevinsky and Hassan Safouhi},
	Title = {Computing Energy Eigenvalues of Anharmonic Oscillators using the Double Exponential Sinc collocation Method},
	Year = {2014}
}

