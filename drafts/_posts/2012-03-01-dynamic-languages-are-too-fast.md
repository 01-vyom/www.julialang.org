---
layout: post
title:  Dynamic Languages Are Too Fast
authors:
    - <a href="http://github.com/JeffBezanson/">Jeff Bezanson</a>
    - <a href="http://karpinski.org/">Stefan Karpinski</a>
---

We're going to make a seemingly paradoxical claim:
*in order to be much faster, dynamic languages ought to be much slower.*
This strange assertion seems more like a koan than a legitimate idea about how to design dynamic programming languages.
However, it's a serious proposition, and it's central to the design of the Julia language.

Like many koans (and jokes), the key to enlightenment is changing frames of reference — and understanding which reference frame applies to which part of the koan.
In this case, the two distinct meanings of "speed" in the koan are:

1. Dynamic language speed when interpreted naïvely
2. Dynamic language speed when executed by a clever, type-inferencing JIT.

Decoded into these reference frames, our claim becomes:
in order to be much faster when executed by a clever, type-inferencing JIT, dynamic languages ought to be much slower when interpreted naïvely.
While this version of the claim is far less mysterious, it is still a rather non-obvious claim that we have to provide evidence for.

Pick any mainstream dynamic language out there today: Lisp, Perl, Python, Ruby, JavaScript, Matlab, Lua.
When every single one of these languages was first implemented, that implementation used a relatively naïve interpreter to execute programs.
Compiling source to bytecode and then interpreting bytecode eventually became standard since it avoids re-parsing the source every time it executes, but even that was not something most early implementations did.
Interpretation introduces a fair amount of overhead:
a really good interpreter can execute code 10-50 times slower than native code with comparable functionality generated by a compiler.
Less fast interpreters often run thousands of times slower than native code with comparable functionality.
For many purposes, that's fast enough, and the tradeoff of speed for ease-of-use provided by dynamic languages is worth it.
So the popularity of dynamic languages grew.

Java Virtual Machine (JVM) implementations popularized just-in-time compilation of bytecode to native machine code, which could then execute at full speed.
This technique can allow dynamic languages run their at speeds approaching that of compiled languages:
you compile the code right before running it, effectively bringing compile- and run-time together.