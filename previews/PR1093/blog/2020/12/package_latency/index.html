<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=stylesheet  href="/previews/PR1093/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/previews/PR1093/css/app.css"> <link rel=stylesheet  href="/previews/PR1093/css/franklin.css"> <link rel=stylesheet  href="/previews/PR1093/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/previews/PR1093/libs/buttons.js"></script> <!-- --> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <link rel=icon  href="/previews/PR1093/assets/infra/julia.ico"> <link rel=stylesheet  href="/previews/PR1093/libs/highlight/github.min.css"> <title>Reducing compiler latency in Julia packages</title> <style> .container ul li p {margin-bottom: 0;} </style> <style> .main { font-family: Georgia; } .main pre { margin-left: auto; margin-right: auto; } .main { width: 100%; font-size: 100%; } .main code { font-size: 90%; } .main pre code { font-size: 90%; } @media (min-width: 940px) { .main { width: 800px; } .container.blog-title { width: 800px;} } </style> <meta property="og:title" content="Reducing compiler latency in Julia packages"> <meta property="og:description" content="Julia runs fast, but suffers from latency due to compilation. This post describes how to detect and eliminate major sources of latency in packages."> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/previews/PR1093/"> <img src="/previews/PR1093/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/research/">Research</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1093/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <div class="container blog-title"> <h1>Reducing compiler latency in Julia packages <a type="application/rss+xml" href="https://julialang.org/feed.xml"> <i class="fa fa-rss-square rss-icon"></i> </a> </h1> <h3> <span style="font-weight: lighter;"> 1 December 2020 </span> | <span style="font-weight: bold;"></span> <span style="font-weight: bold;">Tim Holy and Nathan Daly </span> </h3> </div> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2020/12/package_latency.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><div class=franklin-toc ><ol><li><a href="#taking_a_baseline_measurement">Taking a baseline measurement</a><li><a href="#identifying_the_most_costly-to-infer_methods">Identifying the most costly-to-infer methods</a><li><a href="#strategy_1_reducing_the_cost_of_argument_type-diversity">Strategy 1: reducing the cost of argument type-diversity</a><li><a href="#strategy_2_inspecting_and_addressing_inference_failures">Strategy #2: inspecting and addressing inference failures</a><ol><li><a href="#identifying_inference_failures">Identifying inference failures</a><li><a href="#a_spurious_inference_failure_that_can_be_addressed_by_precompilation">A spurious &quot;inference failure&quot; that can be addressed by precompilation</a><li><a href="#an_example_with_an_unavoidable_inference_failure_more_opportunities_to_reduce_specialization">An example with an unavoidable inference failure: more opportunities to reduce specialization</a><li><a href="#identifying_and_fixing_avoidable_inference_failures">Identifying and fixing avoidable inference failures</a><ol><li><a href="#the_case_of_collect_and_usage_of_callingframe">The case of <code>collect</code> &#40;and usage of <code>callingframe</code>&#41;</a><li><a href="#fixing_avoidable_inference_problems">Fixing avoidable inference problems</a></ol></ol><li><a href="#final_results">Final results</a><li><a href="#conclusions">Conclusions</a></ol></div> <p><a href="https://julialang.org/">The Julia programming language</a> delivers remarkable runtime performance and flexibility. Julia&#39;s flexibility depends on the ability to of methods to handle arguments of many different types. This flexibility would be in competition with runtime performance, were it not for the &quot;trick&quot; of <em>method specialization</em>. Julia compiles a separate &quot;instance&quot; of a method for each distinct combination of argument types; this specialization allows code to be optimized to take advantage of specific features of the inputs, eliminating most of the <em>runtime</em> cost that would otherwise be the result of Julia&#39;s flexibility.</p> <p>Unfortunately, method specialization has its own cost: compiler latency. Since compilation is expensive, there is a measurable delay that occurs on first invokation of a method for a specific combination of argument types. There are cases where one can do some of this work once, in advance, using utilities like <a href="https://docs.julialang.org/en/v1/base/base/#Base.precompile"><code>precompile</code></a> or building a custom system with <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler</a>. In other cases, the number of distinct argument types that a method might be passed seems effectively infinite, and in such cases precompilation seems unlikely to be a comprehensive solution.</p> <p>This post introduces some new tools to detect the major sources of compiler latency, focusing specifically on the <em>type inference</em> step of compilation. <a href="https://docs.julialang.org/en/v1/devdocs/eval/#dev-type-inference">Type inference</a> is the process of deducing the types of all the internal variables in a method, given the types of the input arguments. This is an early, but crucial, step in compilation, and the first to introduce substantial latency. Later steps &#40;optimization and native-code generation&#41; are typically even more expensive, but in many cases inference latency is roughly proportional to these other forms of latency: typically, each run of inference is followed by these later steps of compilation. &#40;An exception are methods annotated with <a href="https://docs.julialang.org/en/v1/base/base/#Base.@nospecialize"><code>@nospecialize</code></a>, which get compiled to native code only for generic argument types. Julia also has a number of heuristics which in essence add <code>@nospecialize</code> automatically for certain combinations of argument types.&#41;</p> <p>In this post, we&#39;ll walk through the process of analyzing and optimizing the <a href="https://github.com/JuliaData/DataFrames.jl">DataFrames</a> package. We chose DataFrames for several reasons:</p> <ul> <li><p>DataFrames is widely used</p> <li><p>the DataFrames API seems fairly stable, and they are approaching their 1.0 release</p> <li><p>DataFrames is designed to work with any type of data and any user-supplied transformation functions, and so <a href="https://discourse.julialang.org/t/best-practices-for-profiling-compilation/48249">faces substantial latency challenges</a></p> <li><p>DataFrames is developed by a sophisticated and conscientious team, and the package has already been <a href="https://discourse.julialang.org/t/release-announcements-for-dataframes-jl/18258/112?u&#61;tim.holy">aggressively optimized for latency</a> using tools that were, until now, state-of-the-art; this sets a high bar for any new tools &#40;don&#39;t worry, we&#39;re going to crest that bar ;-&#41; &#41;</p> <li><p>In a previous <a href="https://julialang.org/blog/2020/08/invalidations/">blog post</a>, one of the authors indirectly &quot;called out&quot; DataFrames &#40;and more accurately its dependency <a href="https://github.com/JuliaData/CategoricalArrays.jl">CategoricalArrays</a>&#41; for having a lot of difficult-to-fix invalidations. To their credit, the developers made changes that dropped the number of invalidations by about 10×. This post is partly an attempt to return the favor. That said, we hope they don&#39;t mind being guinea pigs for these new tools.</p> </ul> <p>This post is based on DataFrames 0.22.1, and version 0.9 of the underlying CategoricalArrays. If you follow the steps of this blog post with different versions, you&#39;re likely to get different results from those shown here, partly because many of the issues we identified have been fixed in more recent releases. It should also be emphasize that these analysis tools are only supported on Julia 1.6 and above; at the time of this post, Julia 1.6 not yet to &quot;alpha&quot; release phase but can be obtained from <a href="https://julialang.org/downloads/#nightly_builds">nightly</a> snapshots or built from <a href="https://github.com/JuliaLang/julia">source</a>.</p> <h2 id=taking_a_baseline_measurement ><a href="#taking_a_baseline_measurement">Taking a baseline measurement</a></h2> <p>A good first step is to roughly document the current compiler latency costs. For a package like DataFrames that contains an extensive test suite, an easy way to do this is to time the entire test suite:</p> <pre><code class="julia hljs">shell&gt; pwd
/home/tim/.julia/dev/DataFrames/test

julia&gt; <span class=hljs-keyword >using</span> DataFrames; <span class=hljs-meta >@time</span> include(<span class=hljs-string >&quot;runtests.jl&quot;</span>)
Running tests:
⋮                     <span class=hljs-comment ># lots of suppressed lines of output</span>
<span class=hljs-number >620.652994</span> seconds (<span class=hljs-number >1.25</span> G allocations: <span class=hljs-number >72.799</span> GiB, <span class=hljs-number >3.35</span>% gc time, <span class=hljs-number >96.29</span>% compilation time)</code></pre> <p>Julia told us that a whopping 96.29&#37; of the time was spent on compilation. It&#39;s pretty common among Julia packages that compilation is the dominant cost of running the test suite. Unsurprisingly, it&#39;s considerably faster if we just run the suite a second time within the same session:</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-meta >@time</span> include(<span class=hljs-string >&quot;runtests.jl&quot;</span>)
⋮
<span class=hljs-number >235.602932</span> seconds (<span class=hljs-number >396.67</span> M allocations: <span class=hljs-number >23.434</span> GiB, <span class=hljs-number >3.05</span>% gc time, <span class=hljs-number >89.01</span>% compilation time)</code></pre> <p>While this is much faster, you&#39;ll note that compilation still accounts for almost 90&#37; of the time. Why is there any recompilation at all? One reason is that tests that &#40;re&#41;define functions, including lines like</p> <pre><code class="julia hljs">map(x-&gt;x^<span class=hljs-number >2</span>, a)   <span class=hljs-comment ># when run from &quot;top level,&quot; this defines a new anonymous function</span></code></pre>
<p>force a new round of specialization of the <code>map</code> method.  DataFrames has a <em>lot</em> of tests that look like this.</p>
<p>Having obtained this simple baseline measurement, let&#39;s get started.</p>
<h2 id=identifying_the_most_costly-to-infer_methods ><a href="#identifying_the_most_costly-to-infer_methods">Identifying the most costly-to-infer methods</a></h2>
<p>Our first goal is to identify methods that cost the most in inference. To do this, start from a fresh Julia session and do the following:</p>
<pre><code class="julia hljs">shell&gt; pwd
/home/tim/.julia/dev/DataFrames/test

julia&gt; <span class=hljs-keyword >using</span> SnoopCompile

julia&gt; tinf = <span class=hljs-meta >@snoopi_deep</span> include(<span class=hljs-string >&quot;runtests.jl&quot;</span>);
Running tests:
⋮</code></pre>
<p><code>@snoopi_deep</code> is a new tool in <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile</a> which leverages new functionality in Julia.  Like the older <code>@snoopi</code>, it measures what is being inferred and how much time it takes.  However, <code>@snoopi</code> measures aggregate time for each &quot;entrance&quot; into inference, and it includes the time spent inferring all the methods that get inferrably dispatched from the entrance point.  In contrast, <code>@snoopi_deep</code> extracts this data for each method instance, regardless of whether it is an &quot;entrance point&quot; or called by something else.</p>
<p>Having obtained these measurements in <code>tinf</code>, we can now do a lot of analysis. <code>tinf</code> is a very large tree &#40;warning: printing the whole tree takes minutes, but you can interrupt it with Ctrl-C&#41;:</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> AbstractTrees

julia&gt; print_tree(tinf)
<span class=hljs-number >4.43487909448e8</span>μsec: MethodInstance <span class=hljs-keyword >for</span> ROOT()
├─ <span class=hljs-number >332.049</span>μsec: MethodInstance <span class=hljs-keyword >for</span> include(::<span class=hljs-built_in >String</span>)
│  └─ <span class=hljs-number >118.253</span>μsec: MethodInstance <span class=hljs-keyword >for</span> getproperty(::<span class=hljs-built_in >Module</span>, ::<span class=hljs-built_in >Symbol</span>)
├─ <span class=hljs-number >1692.625</span>μsec: MethodInstance <span class=hljs-keyword >for</span> require(::<span class=hljs-built_in >Module</span>, ::<span class=hljs-built_in >Symbol</span>)
│  ├─ <span class=hljs-number >98.411</span>μsec: MethodInstance <span class=hljs-keyword >for</span> identify_package(::<span class=hljs-built_in >Module</span>, ::<span class=hljs-built_in >String</span>)
│  │  └─ <span class=hljs-number >1029.586</span>μsec: MethodInstance <span class=hljs-keyword >for</span> identify_package(::Base.PkgId, ::<span class=hljs-built_in >String</span>)
│  │     ├─ <span class=hljs-number >79.496</span>μsec: MethodInstance <span class=hljs-keyword >for</span> getproperty(::Base.PkgId, ::<span class=hljs-built_in >Symbol</span>)
│  │     ├─ <span class=hljs-number >28.933</span>μsec: MethodInstance <span class=hljs-keyword >for</span> convert(::<span class=hljs-built_in >Type</span>{<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, Base.PkgId}}, ::Base.PkgId)
│  │     ├─ <span class=hljs-number >32.701</span>μsec: MethodInstance <span class=hljs-keyword >for</span> getproperty(::Base.PkgId, ::<span class=hljs-built_in >Symbol</span>)
│  │     ├─ <span class=hljs-number >571.372</span>μsec: MethodInstance <span class=hljs-keyword >for</span> identify_package(::<span class=hljs-built_in >String</span>)
│  │     └─ <span class=hljs-number >1020.444</span>μsec: MethodInstance <span class=hljs-keyword >for</span> manifest_deps_get(::<span class=hljs-built_in >String</span>, ::Base.PkgId, ::<span class=hljs-built_in >String</span>)
│  │        ├─ <span class=hljs-number >3478.298</span>μsec: MethodInstance <span class=hljs-keyword >for</span> explicit_manifest_deps_get(::<span class=hljs-built_in >String</span>, ::Base.UUID, ::<span class=hljs-built_in >String</span>)
│  │        │  ⋮</code></pre>
<p>Each branch of a node indents further to the right, and represents callees of the node.  The <code>ROOT</code> object is special: it measures the approximate time spent on the entire operation, excepting inference, and consequently combines native code generation and runtime. Each other entry reports the time needed to infer just that method instance, not including the time spent inferring its callees.</p>
<p>One of the first steps you can take is to &quot;flatten&quot; the tree, sorting the nodes in increasing order of inference time:</p>
<pre><code class="julia hljs">julia&gt; flatten_times(tinf)
<span class=hljs-number >663530</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, Core.Compiler.Timings.InferenceFrameInfo}}:
      <span class=hljs-number >7.394e-6</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(MethodInstance <span class=hljs-keyword >for</span> copy(::InvertedIndices.InvertedIndexIterator{<span class=hljs-built_in >Int64</span>, Base.Slice{Base.OneTo{<span class=hljs-built_in >Int64</span>}}, Base.OneTo{<span class=hljs-built_in >Int64</span>}}), <span class=hljs-number >0x0000000000007741</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[Core.Const(copy), InvertedIndices.InvertedIndexIterator{<span class=hljs-built_in >Int64</span>, Base.Slice{Base.OneTo{<span class=hljs-built_in >Int64</span>}}, Base.OneTo{<span class=hljs-built_in >Int64</span>}}], <span class=hljs-number >2</span>, <span class=hljs-literal >false</span>)
               ⋮
   <span class=hljs-number >0.249446057</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(MethodInstance <span class=hljs-keyword >for</span> do_call(::<span class=hljs-built_in >Type</span>, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >NamedTuple</span>{(:a, :b), <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Int64</span>, <span class=hljs-built_in >Int64</span>}}}}, ::<span class=hljs-built_in >Int64</span>), <span class=hljs-number >0x0000000000007632</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[Core.Const(DataFrames.do_call), <span class=hljs-built_in >Type</span>, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, GroupedDataFrame{DataFrame}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >NamedTuple</span>{(:a, :b), <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Int64</span>, <span class=hljs-built_in >Int64</span>}}}}, <span class=hljs-built_in >Int64</span>, <span class=hljs-built_in >Union</span>{}], <span class=hljs-number >8</span>, <span class=hljs-literal >false</span>)
   <span class=hljs-number >0.343503454</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(Toplevel MethodInstance thunk, <span class=hljs-number >0x0000000000007741</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[<span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}  …  <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}], <span class=hljs-number >0</span>, <span class=hljs-literal >false</span>)
   <span class=hljs-number >0.369120319</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(Toplevel MethodInstance thunk, <span class=hljs-number >0x0000000000007741</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[<span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}  …  <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}], <span class=hljs-number >0</span>, <span class=hljs-literal >false</span>)
   <span class=hljs-number >0.923845737</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(MethodInstance <span class=hljs-keyword >for</span> precompile(::<span class=hljs-built_in >Bool</span>), <span class=hljs-number >0x0000000000007759</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[Core.Const(DataFrames.precompile), <span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}  …  <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}, <span class=hljs-built_in >Union</span>{}], <span class=hljs-number >2</span>, <span class=hljs-literal >false</span>)
 <span class=hljs-number >443.487909448</span> =&gt; Core.Compiler.Timings.InferenceFrameInfo(MethodInstance <span class=hljs-keyword >for</span> ROOT(), <span class=hljs-number >0x0000000000000000</span>, <span class=hljs-built_in >Any</span>[], <span class=hljs-built_in >Any</span>[Core.Const(Core.Compiler.Timings.ROOT)], <span class=hljs-number >1</span>, <span class=hljs-literal >false</span>)</code></pre>
<p>We see &gt;600K nodes, of which some take an appreciable fraction of a second to infer.  It is these most expensive method instances that should be the main focus of our optimization.  The <code>thunk</code> items represent calls made from the test file itself, so aside from <code>precompile</code>, which is in a special category, the worst call here is <code>DataFrames.do_call</code>.</p>
<p>This is a truncated version of the output; if you look at more of the entries carefully, you&#39;ll notice a number of near-duplicates: <code>do_call</code> appears numerous times, with different argument types. While <code>do_call</code> has eight methods, there are many more entries in <code>flatten_times&#40;tinf&#41;</code> than these eight, and this is explained by multiple specializations of single methods.  It&#39;s of particular interest to aggregate all the instances of a particular method, since this represents the cost of the method itself:</p>
<pre><code class="julia hljs">julia&gt; tm = accumulate_by_method(flatten_times(tinf))
<span class=hljs-number >6974</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-built_in >Method</span>}}:
           <span class=hljs-number >1.465e-5</span> =&gt; LogBo256L(::<span class=hljs-built_in >Val</span>{:<span class=hljs-literal >ℯ</span>}, ::<span class=hljs-built_in >Type</span>{<span class=hljs-built_in >Float64</span>}) <span class=hljs-keyword >in</span> Base.Math at special/exp.jl:<span class=hljs-number >46</span>
                    ⋮
 <span class=hljs-number >3.5665204619999993</span> =&gt; iterate(t::<span class=hljs-built_in >Tuple</span>, i::<span class=hljs-built_in >Int64</span>) <span class=hljs-keyword >in</span> Base at tuple.jl:<span class=hljs-number >64</span>
  <span class=hljs-number >4.829588363999999</span> =&gt; do_call(f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, idx::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, starts::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s248&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s248&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, ends::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s146&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s146&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T}, i::<span class=hljs-built_in >Integer</span>) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >91</span>
         <span class=hljs-number >7.12010299</span> =&gt; <span class=hljs-string >var&quot;#_combine_prepare#473&quot;</span>(keepkeys::<span class=hljs-built_in >Bool</span>, ungroup::<span class=hljs-built_in >Bool</span>, copycols::<span class=hljs-built_in >Bool</span>, keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>, ::typeof(DataFrames._combine_prepare), gd::GroupedDataFrame, cs::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Regex</span>, <span class=hljs-built_in >AbstractString</span>, <span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Signed</span>, <span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Unsigned</span>, <span class=hljs-built_in >Pair</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >Type</span>, All, Between, Cols, InvertedIndex}...) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >21</span>
 <span class=hljs-number >11.909738723000002</span> =&gt; _combine_with_first(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>, DataFrameRow}, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >NamedTuple</span>}, firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>}) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >21</span>
      <span class=hljs-number >443.487909448</span> =&gt; ROOT() <span class=hljs-keyword >in</span> Core.Compiler.Timings at compiler/typeinfer.jl:<span class=hljs-number >75</span></code></pre>
<p>This much smaller number of entries paints a somewhat different picture from the one above: <code>do_call</code> is now the third-worst offender, but it is handily beat by <code>_combine_with_first</code>.  How can this happen? A key is to look at the number of specializations of each function:</p>
<pre><code class="julia hljs">julia&gt; length(methodinstances(DataFrames._combine_with_first))
<span class=hljs-number >624</span></code></pre>
<p>The aggregate cost is a sum of the cost of all individual <code>MethodInstance</code>s. &#40;<code>do_call</code> has even more instances, at 1260, but some of these instances must be must less time-consuming than the worst offender we noted above.&#41;</p>
<p>This is a <em>lot</em> of specializations, and their aggregate cost is high: not only is there the 12s spent inferring all these instances of <code>_combine_with_first</code>, there is also the unmeasured cost of native code generation for these specializations.  If we can do something to reduce the number of specializations, or to make the compilation cost of each much smaller, we might be able to shave a fair amount from the cost of running the test suite.</p>
<h2 id=strategy_1_reducing_the_cost_of_argument_type-diversity ><a href="#strategy_1_reducing_the_cost_of_argument_type-diversity">Strategy 1: reducing the cost of argument type-diversity</a></h2>
<p>Let&#39;s take a look at <code>_combine_with_first</code>:</p>
<pre><code class="julia hljs">julia&gt; methods(DataFrames._combine_with_first)
<span class=hljs-comment ># 1 method for generic function &quot;_combine_with_first&quot;:</span>
[<span class=hljs-number >1</span>] _combine_with_first(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>, DataFrameRow}, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >NamedTuple</span>}, firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>}) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >21</span></code></pre>
<p>with implementation</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> _combine_with_first(first::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >NamedTuple</span>, DataFrameRow, AbstractDataFrame},
                             f::Base.Callable, gd::GroupedDataFrame,
                             incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >NamedTuple</span>},
                             firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{&lt;:<span class=hljs-built_in >Integer</span>}})
    extrude = <span class=hljs-literal >false</span>

    <span class=hljs-keyword >if</span> first <span class=hljs-keyword >isa</span> AbstractDataFrame
        n = <span class=hljs-number >0</span>
        eltys = eltype.(eachcol(first))
    <span class=hljs-keyword >elseif</span> first <span class=hljs-keyword >isa</span> <span class=hljs-built_in >NamedTuple</span>{&lt;:<span class=hljs-built_in >Any</span>, &lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>}}}
        n = <span class=hljs-number >0</span>
        eltys = map(eltype, first)
    <span class=hljs-keyword >elseif</span> first <span class=hljs-keyword >isa</span> DataFrameRow
        n = length(gd)
        eltys = [eltype(parent(first)[!, i]) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> parentcols(index(first))]
    <span class=hljs-keyword >elseif</span> firstmulticol == <span class=hljs-built_in >Val</span>(<span class=hljs-literal >false</span>) &amp;&amp; first[<span class=hljs-number >1</span>] <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >AbstractArray</span>{&lt;:<span class=hljs-built_in >Any</span>, <span class=hljs-number >0</span>}, <span class=hljs-built_in >Ref</span>}
        extrude = <span class=hljs-literal >true</span>
        first = wrap_row(first[<span class=hljs-number >1</span>], firstmulticol)
        n = length(gd)
        eltys = (typeof(first[<span class=hljs-number >1</span>]),)
    <span class=hljs-keyword >else</span> <span class=hljs-comment ># other NamedTuple giving a single row</span>
        n = length(gd)
        eltys = map(typeof, first)
        <span class=hljs-keyword >if</span> any(x -&gt; x &lt;: <span class=hljs-built_in >AbstractVector</span>, eltys)
            throw(<span class=hljs-built_in >ArgumentError</span>(<span class=hljs-string >&quot;mixing single values and vectors in a named tuple is not allowed&quot;</span>))
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    idx = isnothing(idx_agg) ? <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int</span>}(<span class=hljs-literal >undef</span>, n) : idx_agg
    <span class=hljs-keyword >local</span> initialcols
    <span class=hljs-keyword >let</span> eltys=eltys, n=n <span class=hljs-comment ># Workaround for julia#15276</span>
        initialcols = ntuple(i -&gt; Tables.allocatecolumn(eltys[i], n), _ncol(first))
    <span class=hljs-keyword >end</span>
    targetcolnames = tuple(propertynames(first)...)
    <span class=hljs-keyword >if</span> !extrude &amp;&amp; first <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{AbstractDataFrame,
                                   <span class=hljs-built_in >NamedTuple</span>{&lt;:<span class=hljs-built_in >Any</span>, &lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>}}}}
        outcols, finalcolnames = _combine_tables_with_first!(first, initialcols, idx, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>,
                                                             f, gd, incols, targetcolnames,
                                                             firstmulticol)
    <span class=hljs-keyword >else</span>
        outcols, finalcolnames = _combine_rows_with_first!(first, initialcols, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>,
                                                           f, gd, incols, targetcolnames,
                                                           firstmulticol)
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> idx, outcols, collect(<span class=hljs-built_in >Symbol</span>, finalcolnames)
<span class=hljs-keyword >end</span></code></pre>
<p>Obviously, it helps if you know something about the internals of the package, which we, the authors of this blog post, do not.   But even if you are as naive as we are, you can pretty quickly discover a couple of key points. First, note that this method isn&#39;t entirely trivial; size alone is a &#40;very rough&#41; predictor of the cost of inference, and at nearly 50 lines this seems likely to be a method worth optimizing.  &#40;Conversely, 1-line methods rarely require the kind of attention we&#39;re giving to <code>_combine_with_first</code>, unless there is extensive inlining.&#41;  Second, there are several arguments that might be specialized on:</p>
<ul>
<li><p>two arguments &#40;<code>first</code> and <code>incols</code>&#41; could potentially be <code>NamedTuple</code>s, and since <code>&#40;x&#61;1,&#41;</code> and <code>&#40;y&#61;1,&#41;</code> are different <code>NamedTuple</code> types, these arguments alone have potentially-huge possibility for specialization.  &#40;If these are specialized for the particular column names in a DataFrame, then the scope for specialization is essentially limitless.&#41; Indeed, a check <code>methodinstances&#40;DataFrames._combine_with_first&#41;</code> reveals that many of these specializations are for different <code>NamedTuple</code>s.</p>

<li><p>the <code>f::Base.Callable</code> argument is either a function or a type, again a potentially-limitless source of specialization. However, checking the output of <code>methodinstances</code>, you&#39;ll see that this argument is not specialized.  Presumably this is due to the major callers of <code>_combine_with_first</code> using a <code>@nospecialize</code> on their corresponding argument.  In this case, over-specialization does not seem to be a concern, but generally speaking function or type arguments are prime candidates for risk of over-specialization.</p>

</ul>
<p>Some strategies, like adding <code>@nospecialize</code>s, might be effective in reducing compile-time cost.  But without knowing a lot more about this package, it is difficult to know whether this might have undesirable effects on runtime performance.  So here we pursue a different strategy: let&#39;s focus on the fact that inference has to be performed for each unique combination of input types.  Since we have two highly-diverse argument types, the effect is essentially <em>multiplicative</em>.  But we also note that <code>incols</code> is just &quot;passed through&quot;; while we might want to preserve this type information, specializing on <code>incols</code> does not affect any portion of the body of this method other than the final calls to <code>_combine_tables_with_first&#33;</code> or <code>_combine_rows_with_first&#33;</code>.  Consequently, we may be wasting a lot of time specializing code that doesn&#39;t actually change dependening on the type of <code>incols</code>.</p>
<p>Taking advantage of this observation, let&#39;s split the &quot;prelude&quot;–everything before <code>incols</code> gets used–out into a separate method:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> _combine_with_first(first::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >NamedTuple</span>, DataFrameRow, AbstractDataFrame},
                             f::Base.Callable, gd::GroupedDataFrame,
                             incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >NamedTuple</span>},
                             firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{&lt;:<span class=hljs-built_in >Integer</span>}})
    n, eltys, extrude, idx, initialcols, targetcolnames = _combine_with_first_prelude(first, f, gd, firstmulticol, idx_agg)
    <span class=hljs-keyword >if</span> !extrude &amp;&amp; first <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{AbstractDataFrame,
                                   <span class=hljs-built_in >NamedTuple</span>{&lt;:<span class=hljs-built_in >Any</span>, &lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>}}}}
        outcols, finalcolnames = _combine_tables_with_first!(first, initialcols, idx, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>,
                                                             f, gd, incols, targetcolnames,
                                                             firstmulticol)
    <span class=hljs-keyword >else</span>
        outcols, finalcolnames = _combine_rows_with_first!(first, initialcols, <span class=hljs-number >1</span>, <span class=hljs-number >1</span>,
                                                           f, gd, incols, targetcolnames,
                                                           firstmulticol)
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> idx, outcols, collect(<span class=hljs-built_in >Symbol</span>, finalcolnames)
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> _combine_with_first_prelude(first::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >NamedTuple</span>, DataFrameRow, AbstractDataFrame},
                                     f::Base.Callable, gd::GroupedDataFrame,
                                     firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{&lt;:<span class=hljs-built_in >Integer</span>}})
    extrude = <span class=hljs-literal >false</span>

    <span class=hljs-keyword >if</span> first <span class=hljs-keyword >isa</span> AbstractDataFrame
        n = <span class=hljs-number >0</span>
        eltys = eltype.(eachcol(first))
    <span class=hljs-keyword >elseif</span> first <span class=hljs-keyword >isa</span> <span class=hljs-built_in >NamedTuple</span>{&lt;:<span class=hljs-built_in >Any</span>, &lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>}}}
        n = <span class=hljs-number >0</span>
        eltys = map(eltype, first)
    <span class=hljs-keyword >elseif</span> first <span class=hljs-keyword >isa</span> DataFrameRow
        n = length(gd)
        eltys = [eltype(parent(first)[!, i]) <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> parentcols(index(first))]
    <span class=hljs-keyword >elseif</span> firstmulticol == <span class=hljs-built_in >Val</span>(<span class=hljs-literal >false</span>) &amp;&amp; first[<span class=hljs-number >1</span>] <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >AbstractArray</span>{&lt;:<span class=hljs-built_in >Any</span>, <span class=hljs-number >0</span>}, <span class=hljs-built_in >Ref</span>}
        extrude = <span class=hljs-literal >true</span>
        first = wrap_row(first[<span class=hljs-number >1</span>], firstmulticol)
        n = length(gd)
        eltys = (typeof(first[<span class=hljs-number >1</span>]),)
    <span class=hljs-keyword >else</span> <span class=hljs-comment ># other NamedTuple giving a single row</span>
        n = length(gd)
        eltys = map(typeof, first)
        <span class=hljs-keyword >if</span> any(x -&gt; x &lt;: <span class=hljs-built_in >AbstractVector</span>, eltys)
            throw(<span class=hljs-built_in >ArgumentError</span>(<span class=hljs-string >&quot;mixing single values and vectors in a named tuple is not allowed&quot;</span>))
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    idx = isnothing(idx_agg) ? <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int</span>}(<span class=hljs-literal >undef</span>, n) : idx_agg
    <span class=hljs-keyword >local</span> initialcols
    <span class=hljs-keyword >let</span> eltys=eltys, n=n <span class=hljs-comment ># Workaround for julia#15276</span>
        initialcols = ntuple(i -&gt; Tables.allocatecolumn(eltys[i], n), _ncol(first))
    <span class=hljs-keyword >end</span>
    targetcolnames = tuple(propertynames(first)...)

    <span class=hljs-keyword >return</span> n, eltys, extrude, idx, initialcols, targetcolnames
<span class=hljs-keyword >end</span></code></pre>
<p><code>_combine_with_first</code> has to be inferred for all the same argument types as before, but now it is quite short and will hopefully be faster to infer; <code>_combine_with_first_prelude</code> should be inferred for fewer argument types, as it omits all the diversity of <code>incols</code>, and so we might hope it will take less aggregate time.</p>
<p>While we could make several changes before testing again, for the purposes of learning it&#39;s worth knowing the impact of each change.  In this particular case, we can assess the impact by running just the <code>&quot;grouping.jl&quot;</code> tests.  Let&#39;s compare the results for this specific test: before our changes, we had</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> DataFrames; tinf = <span class=hljs-meta >@snoopi_deep</span> include(<span class=hljs-string >&quot;grouping.jl&quot;</span>);

julia&gt; tm = accumulate_by_method(flatten_times(tinf))
<span class=hljs-number >4587</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-built_in >Method</span>}}:
                    ⋮
  <span class=hljs-number >6.247620940999997</span> =&gt; <span class=hljs-string >var&quot;#_combine_prepare#473&quot;</span>(keepkeys::<span class=hljs-built_in >Bool</span>, ungroup::<span class=hljs-built_in >Bool</span>, copycols::<span class=hljs-built_in >Bool</span>, keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>, ::typeof(DataFrames._combine_prepare), gd::GroupedDataFrame, cs::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Regex</span>, <span class=hljs-built_in >AbstractString</span>, <span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Signed</span>, <span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Unsigned</span>, <span class=hljs-built_in >Pair</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >Type</span>, All, Between, Cols, InvertedIndex}...) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >21</span>
 <span class=hljs-number >11.148180995000015</span> =&gt; _combine_with_first(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>, DataFrameRow}, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >NamedTuple</span>}, firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>}) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >21</span>
      <span class=hljs-number >177.799848342</span> =&gt; ROOT() <span class=hljs-keyword >in</span> Core.Compiler.Timings at compiler/typeinfer.jl:<span class=hljs-number >75</span>

julia&gt; length(methodinstances(DataFrames._combine_with_first))
<span class=hljs-number >624</span></code></pre>
<p>and after we had</p>
<pre><code class="julia hljs">julia&gt; tm = accumulate_by_method(flatten_times(tinf))
⋮
 <span class=hljs-number >1.3418041849999998</span> =&gt; _combine_with_first(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>, DataFrameRow}, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >NamedTuple</span>}, firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>}) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >21</span>
 <span class=hljs-number >1.3735432279999995</span> =&gt; getindex(df::DataFrame, row_inds::<span class=hljs-built_in >AbstractVector</span>{T}, col_inds::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Colon</span>, <span class=hljs-built_in >Regex</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, All, Between, Cols, InvertedIndex}) <span class=hljs-keyword >where</span> T <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/dataframe/dataframe.jl:<span class=hljs-number >445</span>
 <span class=hljs-number >1.4696530570000017</span> =&gt; indexed_iterate(t::<span class=hljs-built_in >Tuple</span>, i::<span class=hljs-built_in >Int64</span>, state) <span class=hljs-keyword >in</span> Base at tuple.jl:<span class=hljs-number >86</span>
 <span class=hljs-number >2.3362005260000003</span> =&gt; (::DataFrames.<span class=hljs-string >var&quot;#_combine_prepare##kw&quot;</span>)(::<span class=hljs-built_in >Any</span>, ::typeof(DataFrames._combine_prepare), gd::GroupedDataFrame, cs::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Regex</span>, <span class=hljs-built_in >AbstractString</span>, <span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Signed</span>, <span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Unsigned</span>, <span class=hljs-built_in >Pair</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >Type</span>, All, Between, Cols, InvertedIndex}...) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >21</span>
 <span class=hljs-number >2.4520451379999986</span> =&gt; iterate(t::<span class=hljs-built_in >Tuple</span>, i::<span class=hljs-built_in >Int64</span>) <span class=hljs-keyword >in</span> Base at tuple.jl:<span class=hljs-number >64</span>
  <span class=hljs-number >3.669860345999997</span> =&gt; _combine_tables_with_first!(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>{<span class=hljs-string >var&quot;#s249&quot;</span>, <span class=hljs-string >var&quot;#s248&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s248&quot;</span>&lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, N} <span class=hljs-keyword >where</span> N} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>}, outcols::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, N}}, idx::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, rowstart::<span class=hljs-built_in >Integer</span>, colstart::<span class=hljs-built_in >Integer</span>, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >Tuple</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >NamedTuple</span>}, colnames::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Symbol</span>, N}}, firstmulticol::<span class=hljs-built_in >Val</span>) <span class=hljs-keyword >where</span> N <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >188</span>
  <span class=hljs-number >4.162802701999999</span> =&gt; _combine_with_first_prelude(first::<span class=hljs-built_in >Union</span>{AbstractDataFrame, <span class=hljs-built_in >NamedTuple</span>, DataFrameRow}, f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, gd::GroupedDataFrame, firstmulticol::<span class=hljs-built_in >Val</span>, idx_agg::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>}) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >39</span>
 <span class=hljs-number >4.4092450299999975</span> =&gt; do_call(f::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Type</span>}, idx::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s249&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s249&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, starts::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s248&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s248&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, ends::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s146&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s146&quot;</span>&lt;:<span class=hljs-built_in >Integer</span>, gd::GroupedDataFrame, incols::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T}, i::<span class=hljs-built_in >Integer</span>) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >91</span>
 <span class=hljs-number >6.1610018790000005</span> =&gt; <span class=hljs-string >var&quot;#_combine_prepare#473&quot;</span>(keepkeys::<span class=hljs-built_in >Bool</span>, ungroup::<span class=hljs-built_in >Bool</span>, copycols::<span class=hljs-built_in >Bool</span>, keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>, ::typeof(DataFrames._combine_prepare), gd::GroupedDataFrame, cs::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Regex</span>, <span class=hljs-built_in >AbstractString</span>, <span class=hljs-built_in >Function</span>, <span class=hljs-built_in >Signed</span>, <span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Unsigned</span>, <span class=hljs-built_in >Pair</span>, <span class=hljs-built_in >AbstractVector</span>{T} <span class=hljs-keyword >where</span> T, <span class=hljs-built_in >Type</span>, All, Between, Cols, InvertedIndex}...) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >21</span>
      <span class=hljs-number >173.067687099</span> =&gt; ROOT() <span class=hljs-keyword >in</span> Core.Compiler.Timings at compiler/typeinfer.jl:<span class=hljs-number >75</span>

julia&gt; length(methodinstances(DataFrames._combine_with_first))
<span class=hljs-number >624</span>

julia&gt; length(methodinstances(DataFrames._combine_with_first_prelude))
<span class=hljs-number >259</span></code></pre>
<p>Now we have to look quite a ways back in the list to see the cost of <code>_combine_with_first</code>, despite having just as many instances as before. Meanwhile, we have fewer than half as many instances of <code>_combine_with_first_prelude</code>, for an aggregate cost of 4.16s.  The sum of <code>5.5s</code> is much less than the <code>11.15s</code> when we started; moreover, notice that the total time for <code>ROOT</code> dropped by almost 5s, presumably reflecting an additional decrease in the cost of native code generation.  We saved more than 10s just by moving part of the body out into a separate method.</p>
<p>This strategy can be applied in other places too.  Now, the most expensive method is <a href="https://github.com/JuliaData/DataFrames.jl/blob/86a5ee6cbb539096ef012b790ea16c518b7536f5/src/groupeddataframe/splitapplycombine.jl#L21-L111"><code>_combine_prepare</code></a> &#40;technically, the &quot;body method&quot; <code>#_combine_prepare#473</code> that Julia automatically generates to do the work of the method once all keyword arguments have been assigned; note also the <code>var&quot;#_combine_prepare##kw&quot;</code> just a bit higher up, which is the keyword-filling portion of this method&#41;.  If we look at <code>methodinstances&#40;DataFrames.var&quot;#_combine_prepare#473&quot;&#41;</code>, we see lots of specializations on the final <code>cs</code> argument&#40;s&#41;.  However, the source code is annotated <code>@nospecialize</code>, so all this inference specialization may initially be a surprise.&#91;<a href="#footnote1">†</a>&#93;   We can save this cost by noting that <code>cs</code> is only used to construct <code>cs_vec</code>, and consequently splitting it into</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> _combine_prepare(gd::GroupedDataFrame,
                          <span class=hljs-meta >@nospecialize</span>(cs::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Pair</span>, Base.Callable,
                                        ColumnIndex, MultiColumnIndex}...);
                          keepkeys::<span class=hljs-built_in >Bool</span>, ungroup::<span class=hljs-built_in >Bool</span>, copycols::<span class=hljs-built_in >Bool</span>,
                          keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>)
    <span class=hljs-keyword >if</span> !ungroup &amp;&amp; !keepkeys
        throw(<span class=hljs-built_in >ArgumentError</span>(<span class=hljs-string >&quot;keepkeys=false when ungroup=false is not allowed&quot;</span>))
    <span class=hljs-keyword >end</span>

    cs_vec = []
    <span class=hljs-keyword >for</span> p <span class=hljs-keyword >in</span> cs
        <span class=hljs-keyword >if</span> p === nrow
            push!(cs_vec, nrow =&gt; :nrow)
        <span class=hljs-keyword >elseif</span> p <span class=hljs-keyword >isa</span> <span class=hljs-built_in >AbstractVecOrMat</span>{&lt;:<span class=hljs-built_in >Pair</span>}
            append!(cs_vec, p)
        <span class=hljs-keyword >else</span>
            push!(cs_vec, p)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> _combine_prepare(gd, cs_vec, keepkeys, ungroup, copycols, keeprows, renamecols)
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> _combine_prepare(gd::GroupedDataFrame,
                          cs_vec::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Any</span>},
                          keepkeys::<span class=hljs-built_in >Bool</span>, ungroup::<span class=hljs-built_in >Bool</span>, copycols::<span class=hljs-built_in >Bool</span>,
                          keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>)
    <span class=hljs-keyword >if</span> any(x -&gt; x <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Pair</span> &amp;&amp; first(x) <span class=hljs-keyword >isa</span> <span class=hljs-built_in >Tuple</span>, cs_vec)
...</code></pre>
<p>eliminates most of the inference time.</p>
<p>These and a few other similar changes reduced <code>@time include&#40;&quot;grouping.jl&quot;&#41;</code> in a fresh session by nearly 15&#37;, from 283s to 248s.  In general, reducing argument type-diversity in long methods is one of the easiest ways to reduce latency.  Here we&#39;ve handled this just by splitting methods; if we had a deeper understanding of the package internals, we might consider more extensive refactoring that reduces the diversity at an earlier stage of the call chain and yields even greater benefits.  In either case, the new <code>@snoopi_deep</code> makes it easy to discover which methods would benefit most from this kind of treatment.</p>
<h2 id=strategy_2_inspecting_and_addressing_inference_failures ><a href="#strategy_2_inspecting_and_addressing_inference_failures">Strategy #2: inspecting and addressing inference failures</a></h2>
<p>Some calls produce a result with unpredictable type, and thus to an inference &quot;failure.&quot;  Such failures can be roughly divided into &quot;avoidable&quot; and &quot;unavoidable&quot; failures.  An example of an &quot;unavoidable&quot; failure might be <code>data &#61; load&#40;&quot;myfile.ext&quot;&#41;</code>, where the type of <code>data</code> depends on the contents of <code>&quot;myfile.ext&quot;</code>–there is no plausible way for inference to know what type to expect of <code>data</code>.  In cases like these, it is expected that any calls made to process <code>data</code> will have to be made by <em>runtime dispatch</em>, in which execution is paused to ask <code>data</code> for its type and then search the method tables for compatible methods.</p>
<p>In constrast, some types of inference failure are avoidable. For example, in</p>
<pre><code class="julia hljs">s = []
push!(s, <span class=hljs-number >1</span>, <span class=hljs-number >2</span>)
sum(s)</code></pre>
<p>an inference failure in the <code>sum</code> could have been avoided by defining <code>s &#61; Int&#91;&#93;</code> rather than <code>s &#61; &#91;&#93;</code>.</p>
<p>In real-world circumstances, you&#39;re likely to encounter a mixture of avoidable and unavoidable failures.  Fortunately, it will turn out to be possible to make progress with both types.</p>
<h3 id=identifying_inference_failures ><a href="#identifying_inference_failures">Identifying inference failures</a></h3>
<p>In addition to its ability to measure inference time for each method, the new <code>@snoopi_deep</code> also introduces a new capability that makes identifying inference failures easier than ever: while snooping, inference collects a <a href="https://en.wikipedia.org/wiki/Stack_trace">backtrace</a> upon each new &#40;runtime&#41; entrance into inference.  This makes it possible to discover the caller that triggered runtime dispatch, thus identifying the method and call that fails to infer.  When a package is well-inferred, most of these entrances come from toplevel &#40;the commands you issue in the REPL, or inside a <code>@testset</code>&#41;, but by default these are excluded from SnoopCompile&#39;s reports; the goal is to identify internal, hopefully-avoidable inference failures.</p>
<p>Let&#39;s apply this to DataFrames. After collecting the data with <code>@snoopi_deep include&#40;&quot;runtests.jl&quot;&#41;</code>, we can see inference failures with</p>
<pre><code class="julia hljs">julia&gt; ibs = SnoopCompile.inference_breaks(tinf)
<span class=hljs-number >14812</span>-element <span class=hljs-built_in >Vector</span>{SnoopCompile.InferenceBreak}:
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >1.6178e-5</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> ismissing(::GroupedDataFrame{DataFrame}) from _pretty_tables_highlighter_func at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/prettytables.jl:<span class=hljs-number >14</span>
 ⋮
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >0.818058154</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> (::Base.<span class=hljs-string >var&quot;#show##kw&quot;</span>)(::<span class=hljs-built_in >NamedTuple</span>{(:allrows, :allcols, :allgroups, :rowlabel, :summary, :truncate), <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Int64</span>}}, ::typeof(show), ::Base.PipeEndpoint, ::GroupedDataFrame{DataFrame}) from precompile at ./essentials.jl:<span class=hljs-number >470</span>
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >1.061462398</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> do_call(::ComposedFunction{typeof(Statistics.std), typeof(skipmissing)}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Matrix</span>{<span class=hljs-built_in >Float64</span>}}}, ::<span class=hljs-built_in >Int64</span>) from _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span>
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >1.651674066</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> precompile(::<span class=hljs-built_in >Bool</span>) from precompile at /home/tim/.julia/dev/DataFrames/src/other/precompile.jl:<span class=hljs-number >16</span>
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >2.03736002</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> show(::<span class=hljs-built_in >IOBuffer</span>, ::DataFrameRow{DataFrame, DataFrames.SubIndex{DataFrames.Index, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}}}) from <span class=hljs-comment >#sprint#383 at ./strings/io.jl:105</span></code></pre>
<p>Each line of this display corresponds to a single inference failure, sorted by the cost &#40;in seconds&#41; of the complete recursive inference run after the break.  After the time, the first portion shows the <code>MethodInstance</code> that got executed by runtime dispatch; after &quot;from&quot; it shows the calling method &#40;the one with the inference failure that forced runtime dispatch&#41; and its file:line location. &#40;Because this can be a bit complex, in a REPL session SnoopCompile applies different coloration to the separate portions of this output, but that color doesn&#39;t reproduce here.&#41;</p>
<h3 id=a_spurious_inference_failure_that_can_be_addressed_by_precompilation ><a href="#a_spurious_inference_failure_that_can_be_addressed_by_precompilation">A spurious &quot;inference failure&quot; that can be addressed by precompilation</a></h3>
<p>From the last entry, we would rightly conclude that inferring <code>show</code> for a <code>DataFrameRow</code> can be quite expensive, almost 2s&#33; Does this correspond to an internal inference failure? Let&#39;s extract this element and see:</p>
<pre><code class="julia hljs">julia&gt; ib = ibs[<span class=hljs-keyword >end</span>]
Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >2.03736002</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> show(::<span class=hljs-built_in >IOBuffer</span>, ::DataFrameRow{DataFrame, DataFrames.SubIndex{DataFrames.Index, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}}}) from <span class=hljs-comment >#sprint#383 at ./strings/io.jl:105</span>

julia&gt; stacktrace(ib.bt)
<span class=hljs-number >32</span>-element <span class=hljs-built_in >Vector</span>{Base.StackTraces.StackFrame}:
 exit_current_timer at typeinfer.jl:<span class=hljs-number >166</span> [inlined]
 typeinf(interp::Core.Compiler.NativeInterpreter, frame::Core.Compiler.InferenceState) at typeinfer.jl:<span class=hljs-number >208</span>
 typeinf_ext(interp::Core.Compiler.NativeInterpreter, mi::Core.MethodInstance) at typeinfer.jl:<span class=hljs-number >835</span>
 typeinf_ext_toplevel(interp::Core.Compiler.NativeInterpreter, linfo::Core.MethodInstance) at typeinfer.jl:<span class=hljs-number >868</span>
 typeinf_ext_toplevel(mi::Core.MethodInstance, world::<span class=hljs-built_in >UInt64</span>) at typeinfer.jl:<span class=hljs-number >864</span>
 sprint(f::<span class=hljs-built_in >Function</span>, args::DataFrameRow{DataFrame, DataFrames.SubIndex{DataFrames.Index, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}}}; context::<span class=hljs-built_in >Nothing</span>, sizehint::<span class=hljs-built_in >Int64</span>) at io.jl:<span class=hljs-number >105</span>
 sprint(f::<span class=hljs-built_in >Function</span>, args::DataFrameRow{DataFrame, DataFrames.SubIndex{DataFrames.Index, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}}}) at io.jl:<span class=hljs-number >101</span>
 <span class=hljs-keyword >macro</span> expansion at dataframerow.jl:<span class=hljs-number >434</span> [inlined]
 <span class=hljs-keyword >macro</span> expansion at Test.jl:<span class=hljs-number >1146</span> [inlined]
 top-level scope at dataframerow.jl:<span class=hljs-number >409</span>
 eval at boot.jl:<span class=hljs-number >360</span> [inlined]
 include_string(mapexpr::typeof(identity), mod::<span class=hljs-built_in >Module</span>, code::<span class=hljs-built_in >String</span>, filename::<span class=hljs-built_in >String</span>) at loading.jl:<span class=hljs-number >1089</span>
 ⋮</code></pre>
<p>The first few lines correspond to inference itself, including the timing and backtrace collection performed by <code>@snoopi_deep</code>. The first &quot;real&quot; entry here is for <code>sprint</code>, a <code>Base</code> function and method. Does that mean that <code>sprint</code> has an inference problem? If we look just a little further in the stacktrace, we see this came from line 434 in a &quot;macro expansion&quot; of <code>&quot;dataframerow.jl&quot;</code>, which is the name of one of DataFrames&#39; test files and corresponds to</p>
<pre><code class="julia hljs"><span class=hljs-meta >@test</span> sprint(show, dfr) == <span class=hljs-string >&quot;&quot;&quot;
      ⋮</span></code></pre>
<p>This indicates that this isn&#39;t a true inference failure in the package; SnoopCompile&#39;s filter that excludes calls coming directly from the test suite was defeated by the fact <code>show</code> was executed via <code>sprint</code>. Might we still consider adding a <code>precompile</code> directive to our package, so that we don&#39;t have to pay this cost in each session? Let&#39;s see if we own the method:</p>
<pre><code class="julia hljs">julia&gt; ib.it.mi_info.mi.def
show(io::<span class=hljs-built_in >IO</span>, dfr::DataFrameRow; allcols, rowlabel, eltypes, truncate, kwargs...) <span class=hljs-keyword >in</span> DataFrames at /home/tim/.julia/dev/DataFrames/src/dataframerow/show.jl:<span class=hljs-number >1</span></code></pre>
<p>so indeed the method is defined within <code>DataFrames</code>.  If we were to add a <code>precompile</code> directive for this <code>MethodInstance</code>, we can expect it to succeed in reducing latency.</p>
<p>We&#39;ve identified one place where we could reduce compiler latency by adding a precompile directive, but we could have discovered this with older tools like <code>@snoopi</code>. Let&#39;s do a little further analysis to get something that&#39;s only easily discovered via <code>@snoopi_deep</code>.</p>
<h3 id=an_example_with_an_unavoidable_inference_failure_more_opportunities_to_reduce_specialization ><a href="#an_example_with_an_unavoidable_inference_failure_more_opportunities_to_reduce_specialization">An example with an unavoidable inference failure: more opportunities to reduce specialization</a></h3>
<p>As with <code>flatten_times</code> above, it&#39;s helpful to simplify these results by combining similar items, this time combining inference failures that come from the same source location:</p>
<pre><code class="julia hljs">julia&gt; libs = accumulate_by_callsite(ibs)
<span class=hljs-number >814</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, SnoopCompile.LocationBreaks}}:
            <span class=hljs-number >4.4337e-5</span> =&gt; typeinfo_prefix at ./arrayshow.jl:<span class=hljs-number >536</span> (<span class=hljs-number >1</span> instances)
                      ⋮
    <span class=hljs-number >3.057783997999998</span> =&gt; collect at ./array.jl:<span class=hljs-number >669</span> (<span class=hljs-number >756</span> instances)
   <span class=hljs-number >3.2925309560000007</span> =&gt; _combine_process_agg at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >213</span> (<span class=hljs-number >366</span> instances)
    <span class=hljs-number >3.347522272000001</span> =&gt; iterate at ./generator.jl:<span class=hljs-number >47</span> (<span class=hljs-number >524</span> instances)
   <span class=hljs-number >3.9274885120000005</span> =&gt; <span class=hljs-comment >#groupby#270 at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/groupeddataframe.jl:199 (108 instances)</span>
    <span class=hljs-number >5.153102519000001</span> =&gt; precompile at ./essentials.jl:<span class=hljs-number >470</span> (<span class=hljs-number >248</span> instances)
          <span class=hljs-number >9.494128427</span> =&gt; _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >469</span> (<span class=hljs-number >177</span> instances)
   <span class=hljs-number >12.543704604999991</span> =&gt; _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span> (<span class=hljs-number >963</span> instances)</code></pre>
<p>Once again, we get a quite different picture: now <a href="https://github.com/timholy/DataFrames.jl/blob/66feddffe6069571aac3c6e0c78479cf587e2a84/src/groupeddataframe/splitapplycombine.jl#L443-L477"><code>_combine_process_pair</code></a> sticks out as a particularly-expensive source of inference failure.</p>
<p>Let&#39;s see if we can fix it. First, we extract the last item and then collect some instances of that method:</p>
<pre><code class="julia hljs">julia&gt; lib = libs[<span class=hljs-keyword >end</span>]
<span class=hljs-number >12.543704604999991</span> =&gt; _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span> (<span class=hljs-number >963</span> instances)

julia&gt; lb = lib.second
_combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span> (<span class=hljs-number >963</span> instances)

julia&gt; lb.ibs
<span class=hljs-number >963</span>-element <span class=hljs-built_in >Vector</span>{SnoopCompile.InferenceBreak}:
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >0.000130878</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> do_call(::Main.TestGrouping.<span class=hljs-string >var&quot;#396#404&quot;</span>, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Tuple</span>{}, ::<span class=hljs-built_in >Int64</span>) from _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span>
 ⋮
 Inference <span class=hljs-keyword >break</span> costing <span class=hljs-number >1.061462398</span>s: dispatch MethodInstance <span class=hljs-keyword >for</span> do_call(::ComposedFunction{typeof(Statistics.std), typeof(skipmissing)}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Matrix</span>{<span class=hljs-built_in >Float64</span>}}}, ::<span class=hljs-built_in >Int64</span>) from _combine_process_pair at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/splitapplycombine.jl:<span class=hljs-number >463</span></code></pre>
<p>As expected from the source line of <code>DataFrames/src/groupeddataframe/splitapplycombine.jl:463</code>, all of these are calls to <code>do_call</code>; we can collect all the unique <code>MethodInstance</code>s with <code>umis &#61; unique&#40;ib.it.mi_info.mi for ib in lb.ibs&#41;</code>, for which we get 959 separate instances.  How many instances of the caller are there?</p>
<pre><code class="julia hljs">julia&gt; mis = collect_instances(lb, tinf)
<span class=hljs-number >3</span>-element <span class=hljs-built_in >Vector</span>{Core.MethodInstance}:
 MethodInstance <span class=hljs-keyword >for</span> _combine_process_pair(::<span class=hljs-built_in >Pair</span>, ::<span class=hljs-built_in >Bool</span>, ::DataFrame, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Dict</span>{<span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Int64</span>}}, ::<span class=hljs-built_in >Vector</span>{DataFrames.TransformationResult}, ::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>})
 MethodInstance <span class=hljs-keyword >for</span> _combine_process_pair(::<span class=hljs-built_in >Pair</span>, ::<span class=hljs-built_in >Bool</span>, ::DataFrame, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Dict</span>{<span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Int64</span>}}, ::<span class=hljs-built_in >Vector</span>{DataFrames.TransformationResult}, ::<span class=hljs-built_in >Nothing</span>)
 MethodInstance <span class=hljs-keyword >for</span> _combine_process_pair(::<span class=hljs-built_in >Pair</span>, ::<span class=hljs-built_in >Bool</span>, ::DataFrame, ::GroupedDataFrame{DataFrame}, ::<span class=hljs-built_in >Dict</span>{<span class=hljs-built_in >Symbol</span>, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Int64</span>}}, ::<span class=hljs-built_in >Vector</span>{DataFrames.TransformationResult}, ::<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Nothing</span>, <span class=hljs-built_in >AbstractVector</span>{<span class=hljs-built_in >Int64</span>}})</code></pre>
<p>Just 3&#33; This suggests that <code>_combine_process_pair</code> is a huge source of expansion in type-diversity.  This often happens if, for example, you extract elements from a <code>Vector&#123;Any&#125;</code> or <code>Dict&#123;String,Any&#125;</code>; the container is a single type, but the values it stores could be of very diverse types.  When you have external knowledge that there are only a limited number of possibilities, you might fix it with the <a href="https://github.com/jlapeyre/ManualDispatch.jl">ManualDispatch</a> package.  In this case, even if we ignore the diversity of <a href="https://github.com/timholy/DataFrames.jl/blob/66feddffe6069571aac3c6e0c78479cf587e2a84/src/groupeddataframe/splitapplycombine.jl#L464-L465"><code>fun</code></a>, it&#39;s still pretty high:</p>
<pre><code class="julia hljs"><span class=hljs-comment ># The first parameter in specTypes is do_call, and the second is the `fun` type; for this analysis, we skip these</span>
julia&gt; length(unique(Base.unwrap_unionall(mi.specTypes).parameters[<span class=hljs-number >3</span>:<span class=hljs-keyword >end</span>] <span class=hljs-keyword >for</span> mi <span class=hljs-keyword >in</span> umis))
<span class=hljs-number >52</span></code></pre>
<p>Most of that diversity comes from the <a href="https://github.com/timholy/DataFrames.jl/blob/66feddffe6069571aac3c6e0c78479cf587e2a84/src/groupeddataframe/splitapplycombine.jl#L464-L465"><code>incols</code> argument</a>; if we exclude that parameter as well,</p>
<pre><code class="julia hljs">julia&gt; unique(Base.unwrap_unionall(mi.specTypes).parameters[[<span class=hljs-number >3</span>,<span class=hljs-number >4</span>,<span class=hljs-number >5</span>,<span class=hljs-number >6</span>,<span class=hljs-number >8</span>]] <span class=hljs-keyword >for</span> mi <span class=hljs-keyword >in</span> umis)
<span class=hljs-number >2</span>-element <span class=hljs-built_in >Vector</span>{Core.SimpleVector}:
 svec(<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, GroupedDataFrame{DataFrame}, <span class=hljs-built_in >Int64</span>)
 svec(<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}, GroupedDataFrame{DataFrame}, <span class=hljs-built_in >Int64</span>)</code></pre>
<p>these two types could be handled by manual dispatch.</p>
<p>Given that <code>do_call</code> isn&#39;t annotated with <code>@nospecialize</code>, we might guess that it is a performance hotspot. It would take a bit more understanding of the internals of this package to really come up with a good solution, but let&#39;s experiment a bit.  We open the <code>&quot;groupeddataframe/callprocessing.jl&quot;</code> source file, which contains all the implementations of <code>do_call</code>, and duplicate them while changing the name to <code>do_call_unspecialized</code>, and then adding <code>@nospecialize</code> around the <code>f</code> &#40;equivalent to <code>fun</code> in <code>_combine_process_pair</code>&#41; and <code>incols</code>.  We then modify <code>_combine_process_pair</code> to call <code>do_call_unspecialize</code> instead of <code>do_call</code>.</p>
<p>For the inference breaks that occur at line 469, just to illustrate a slightly different approach we change <code>_combine_process_pair_symbol</code> and <code>_combine_process_pair_astable</code> so that they have <code>@nospecialize</code> around all of the three final arguments &#40;<code>fun</code> already had a <code>@nospecialize</code>, but the other two did not&#41;.  We don&#39;t know for sure whether this is a good idea, but we can always submit a pull request and let the maintainers decide.</p>
<p>Since all, or almost all of these calls again came from the <code>&quot;grouping.jl&quot;</code> test, let&#39;s time the result in a fresh session:</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> DataFrames; <span class=hljs-meta >@time</span> include(<span class=hljs-string >&quot;grouping.jl&quot;</span>)
...
<span class=hljs-number >224.375223</span> seconds (<span class=hljs-number >502.20</span> M allocations: <span class=hljs-number >29.593</span> GiB, <span class=hljs-number >3.69</span>% gc time, <span class=hljs-number >95.47</span>% compilation time)</code></pre>
<p>Since previously we were at 248s, we&#39;ve shaved another 10&#37; off the total time of this test. Whether this is really a good idea will require input from someone who really knows the package internals well.</p>
<h3 id=identifying_and_fixing_avoidable_inference_failures ><a href="#identifying_and_fixing_avoidable_inference_failures">Identifying and fixing avoidable inference failures</a></h3>
<p>Now we focus on &quot;avoidable&quot; failures, cases in which code is written in a way that defeats inference. Our goal here will be to identify and fix such failures.  It should be acknowledged at the outset that <em>fixing inference failures is not guaranteed to reduce compiler latency</em>, and indeed there is a chance that it could increase compilation time by allowing for more aggressive specialization.  That said, there are good reasons to consider fixing inference problems:</p>
<ul>
<li><p>inference with abstract types generally takes more time than inference with concrete types, so by helping inference succeed you may speed it up</p>

<li><p>inference failures almost always hurt runtime performance</p>

<li><p>inference failures leave your package more vulnerable to <a href="https://julialang.org/blog/2020/08/invalidations/">invalidation</a>, which can result in very high latency costs due to recompilation of previously-compiled methods</p>

<li><p>inference failures break the chain of precompilation. If you don&#39;t own the method &#40;if it is not defined in your package&#41; that gets executed after the break, you can&#39;t directly precompile it &#40;a <code>precompile</code> directive will have no impact, because Julia doesn&#39;t know where to store the result&#41;. In contrast, inferrable calls introduce &quot;backedges&quot; that link the precompiled MethodInstance to your package and allow it to be cached in your package&#39;s precompiled <code>*.ji</code> file.</p>

</ul>
<p>Before tackling this problem more generally, let&#39;s look at a specific case that, in the authors&#39; experience, comes up in many packages.</p>
<h4 id=the_case_of_collect_and_usage_of_callingframe ><a href="#the_case_of_collect_and_usage_of_callingframe">The case of <code>collect</code> &#40;and usage of <code>callingframe</code>&#41;</a></h4>
<p>If you look above where <code>accumulate_by_callsite</code> was first introduced, you&#39;ll notice an entry for <code>Base</code>&#39;s <code>collect</code> function.  Let&#39;s extract that entry to <code>lib</code> and look at where some of these breaks in inference came from:</p>
<pre><code class="julia hljs">julia&gt; lb = lib.second
collect at ./array.jl:<span class=hljs-number >669</span> (<span class=hljs-number >756</span> instances)

julia&gt; accumulate_by_callsite(callingframe.(lb.ibs))
<span class=hljs-number >26</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, SnoopCompile.LocationBreaks}}:
          <span class=hljs-number >0.002334037</span> =&gt; <span class=hljs-comment >#describe#61 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:569 (1 instances)</span>
          <span class=hljs-number >0.003319698</span> =&gt; <span class=hljs-comment >#filter#84 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:1017 (1 instances)</span>
          <span class=hljs-number >0.003351513</span> =&gt; <span class=hljs-comment >#filter#91 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:1030 (1 instances)</span>
          <span class=hljs-number >0.003359164</span> =&gt; <span class=hljs-comment >#filter#79 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:1004 (1 instances)</span>
          <span class=hljs-number >0.003822701</span> =&gt; <span class=hljs-comment >#_print_info#58 at /home/tim/.julia/packages/PrettyTables/W16qB/src/private.jl:215 (1 instances)</span>
          <span class=hljs-number >0.003901159</span> =&gt; _expand_to_table at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/selection.jl:<span class=hljs-number >384</span> (<span class=hljs-number >2</span> instances)
          <span class=hljs-number >0.003985022</span> =&gt; do_call_unspecialized at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >197</span> (<span class=hljs-number >1</span> instances)
          <span class=hljs-number >0.004036144</span> =&gt; do_call at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >85</span> (<span class=hljs-number >1</span> instances)
           <span class=hljs-number >0.00404644</span> =&gt; do_call at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >131</span> (<span class=hljs-number >1</span> instances)
          <span class=hljs-number >0.004112145</span> =&gt; <span class=hljs-comment >#_pt_text#96 at /home/tim/.julia/packages/PrettyTables/W16qB/src/backends/text/print.jl:127 (1 instances)</span>
          <span class=hljs-number >0.004178041</span> =&gt; do_call_unspecialized at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/callprocessing.jl:<span class=hljs-number >151</span> (<span class=hljs-number >1</span> instances)
 <span class=hljs-number >0.007789356999999999</span> =&gt; _describe at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:<span class=hljs-number >593</span> (<span class=hljs-number >2</span> instances)
          <span class=hljs-number >0.008026907</span> =&gt; _unstack at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/reshape.jl:<span class=hljs-number >395</span> (<span class=hljs-number >2</span> instances)
 <span class=hljs-number >0.012170741999999998</span> =&gt; <span class=hljs-comment >#DataFrame#658 at /home/tim/.julia/dev/DataFrames/src/other/tables.jl:51 (5 instances)</span>
 <span class=hljs-number >0.014518023000000001</span> =&gt; _combine_with_first_prelude at /home/tim/.julia/dev/DataFrames/src/groupeddataframe/complextransforms.jl:<span class=hljs-number >52</span> (<span class=hljs-number >7</span> instances)
 <span class=hljs-number >0.016908285000000002</span> =&gt; <span class=hljs-comment >#crossjoin#442 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/join.jl:1293 (8 instances)</span>
 <span class=hljs-number >0.017022008999999998</span> =&gt; _describe at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:<span class=hljs-number >639</span> (<span class=hljs-number >8</span> instances)
 <span class=hljs-number >0.024877225000000003</span> =&gt; map at ./abstractarray.jl:<span class=hljs-number >2311</span> (<span class=hljs-number >4</span> instances)
 <span class=hljs-number >0.026061234000000003</span> =&gt; collect at /home/tim/.julia/packages/InvertedIndices/l2dyo/src/InvertedIndices.jl:<span class=hljs-number >60</span> (<span class=hljs-number >2</span> instances)
          <span class=hljs-number >0.034342234</span> =&gt; <span class=hljs-comment >#_stackview#458 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/reshape.jl:185 (6 instances)</span>
          <span class=hljs-number >0.045933587</span> =&gt; <span class=hljs-comment >#stack#449 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/reshape.jl:162 (15 instances)</span>
          <span class=hljs-number >0.053632256</span> =&gt; <span class=hljs-comment >#_pt_text#96 at /home/tim/.julia/packages/PrettyTables/W16qB/src/backends/text/print.jl:120 (2 instances)</span>
  <span class=hljs-number >0.11374774800000001</span> =&gt; schema at /home/tim/.julia/dev/DataFrames/src/other/tables.jl:<span class=hljs-number >24</span> (<span class=hljs-number >14</span> instances)
          <span class=hljs-number >0.181136655</span> =&gt; eval at ./boot.jl:<span class=hljs-number >360</span> (<span class=hljs-number >47</span> instances)
  <span class=hljs-number >0.26616912000000004</span> =&gt; <span class=hljs-comment >#manipulate#399 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/selection.jl:1311 (114 instances)</span>
   <span class=hljs-number >2.2469492800000004</span> =&gt; <span class=hljs-comment >#manipulate#394 at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/selection.jl:1209 (510 instances)</span></code></pre>
<p><code>callingframe</code> is another convenient new tool in SnoopCompile that lets you advance the apparent caller by one Julia frame; using this, we hope to rise out of <code>Base.collect</code> itself and into whatever method &#40;perhaps in DataFrames&#41; called it.  From this, we see that by far the dominant contribution comes from a single site in <code>&quot;selection.jl&quot;</code>.  Here&#39;s a section of that code:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> manipulate(df::DataFrame, <span class=hljs-meta >@nospecialize</span>(cs...); copycols::<span class=hljs-built_in >Bool</span>, keeprows::<span class=hljs-built_in >Bool</span>, renamecols::<span class=hljs-built_in >Bool</span>)
    cs_vec = []
    <span class=hljs-keyword >for</span> v <span class=hljs-keyword >in</span> cs
        <span class=hljs-keyword >if</span> v <span class=hljs-keyword >isa</span> <span class=hljs-built_in >AbstractVecOrMat</span>{&lt;:<span class=hljs-built_in >Pair</span>}
            append!(cs_vec, v)
        <span class=hljs-keyword >else</span>
            push!(cs_vec, v)
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> _manipulate(df, [normalize_selection(index(df), c, renamecols) <span class=hljs-keyword >for</span> c <span class=hljs-keyword >in</span> cs_vec],      <span class=hljs-comment ># this is line 1209</span>
                    copycols, keeprows)
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> _manipulate(df::AbstractDataFrame, <span class=hljs-meta >@nospecialize</span>(normalized_cs), copycols::<span class=hljs-built_in >Bool</span>, keeprows::<span class=hljs-built_in >Bool</span>)</code></pre>
<p>On line 1209, we see a comprehension, and this is one of the common sources for non-inferrable calls to <code>collect</code>.  Why does this yield an inference break? We see that <code>cs_vec</code> is a <code>Vector&#123;Any&#125;</code>, and consequently the result type of the call to <code>normalize_selection</code> can&#39;t be inferrable.  Consequently the call is made by runtime dispatch.</p>
<p>While there are some circumstances where it makes sense to allow this to be made by runtime dispatch, in the majority of cases it&#39;s recommended to annotate the container eltype.  Everything about this code, including the <code>@nospecialize</code> in <code>_manipulate</code>, indicates that this is a section of code that has to deal with unavoidable type diversity, so we&#39;ll pick <code>Any</code> as the container type. Our changes are shown in the following <code>diff</code>:</p>
<pre><code class="diff hljs"><span class=hljs-comment >diff --git a/src/abstractdataframe/selection.jl b/src/abstractdataframe/selection.jl</span>
<span class=hljs-comment >index df58ac2c..07f29bd5 100644</span>
<span class=hljs-comment >--- a/src/abstractdataframe/selection.jl</span>
<span class=hljs-comment >+++ b/src/abstractdataframe/selection.jl</span>
<span class=hljs-meta >@@ -1206,11 +1206,11 @@</span> function manipulate(df::DataFrame, @nospecialize(cs...); copycols::Bool, keeprow
             push!(cs_vec, v)
         end
     end
<span class=hljs-deletion >-    return _manipulate(df, [normalize_selection(index(df), c, renamecols) for c in cs_vec],</span>
<span class=hljs-addition >+    return _manipulate(df, Any[normalize_selection(index(df), c, renamecols) for c in cs_vec],</span>
                     copycols, keeprows)
 end

<span class=hljs-deletion >-function _manipulate(df::AbstractDataFrame, @nospecialize(normalized_cs), copycols::Bool, keeprows::Bool)</span>
<span class=hljs-addition >+function _manipulate(df::AbstractDataFrame, normalized_cs::Vector{Any}, copycols::Bool, keeprows::Bool)</span>
     @assert !(df isa SubDataFrame &amp;&amp; copycols==false)
     newdf = DataFrame()
     # the role of transformed_cols is the following
<span class=hljs-meta >@@ -1308,7 +1308,7 @@</span> function manipulate(dfv::SubDataFrame, @nospecialize(args...); copycols::Bool, k
                 push!(cs_vec, v)
             end
         end
<span class=hljs-deletion >-        return _manipulate(dfv, [normalize_selection(index(dfv), c, renamecols) for c in cs_vec],</span>
<span class=hljs-addition >+        return _manipulate(dfv, Any[normalize_selection(index(dfv), c, renamecols) for c in cs_vec],     # this is line 1311, see above</span>
                            true, keeprows)
     else
         # we do not support transformations here</code></pre>
<p>First, we changed <code>&#91;normalize_...&#93;</code> to <code>Any&#91;normalize_...&#93;</code>; this prevents Julia from even trying to figure out the result type, and results in a predictable <code>Vector&#123;Any&#125;</code> result type for the comprehension.  Second, given that <code>Vector&#123;Any&#125;</code> is a concrete type, we can remove the <code>@nospecialize</code> from <code>_manipulate</code>; this can be quite helpful, because now calls like <code>length&#40;normalized_cs&#41;</code> will be inferrable whereas before they were not.  Finally, to &quot;lock in&quot; these improvements we added a <code>::Vector&#123;Any&#125;</code> type annotation to <code>normalized_cs</code>, and fixed any other callers in DataFrames that might otherwise have been broken by this change–-and this ended up addressing the call on line 1311 that was the second-most costly non-inferrable caller of <code>collect</code>.</p>
<p>When the eltype of a comprehension is inferrable, it&#39;s often best to let Julia infer it; but when you know that you&#39;re dealing with an inherently non-inferrable case, it&#39;s a great idea to specify the eltype directly.  Fortunately, you don&#39;t have to be paranoid about remembering to do so, because <code>@snoopi_deep</code> lets you easily discover any important cases you may have missed.</p>
<p>While none of the other <code>collect</code> call sites have anywhere near the impact of this one, while we&#39;re here it&#39;s not a bad idea to try to fix them.  Briefly, here&#39;s a summary of looking into some of these:</p>
<ul>
<li><p>the <code>eval</code> is unfixable–-one can guess right away that these are called directly from the test suite</p>

<li><p><code>schema</code> is a case where it appears the intent is to deliberately re-introduce a parametrized type for dispatch–very unlikely to be fixable unless one were to reconsider the entire strategy. There are likely very good reasons the authors chose to do this, and at less than 0.2s of inference time the scope for improvement is modest</p>

<li><p><code>#_pt_text#96</code> is in the PrettyTables package, not DataFrames, so let&#39;s ignore it for now</p>

<li><p><code>#stack#449</code> can be fixed by adding another <code>AbstractVector</code> to the <a href="https://github.com/JuliaData/DataFrames.jl/blob/2d0413a018e2647042bcb596916b73cbdd703bc3/src/abstractdataframe/reshape.jl#L162">inner comprehension</a></p>

<li><p><code>#_stackview#458</code> has the same fix as <code>#stack#449</code></p>

<li><p><code>collect</code> and <code>map</code> are from the InvertedIndices package and Base respectively, so again let&#39;s skip these for now</p>

<li><p><code>_describe</code> proves to be a case in which we could fix some inference problems in the code mostly unrelated to <code>collect</code>. Therefore, we&#39;ll stop here and treat that in the next section.</p>

</ul>
<h4 id=fixing_avoidable_inference_problems ><a href="#fixing_avoidable_inference_problems">Fixing avoidable inference problems</a></h4>
<p><code>_describe</code> showed up in our previous analysis of <code>collect</code>. While 17ms is not a lot of time, perhaps <code>collect</code> isn&#39;t the only function it dispatches to:</p>
<pre><code class="julia hljs">julia&gt; filter(libs) <span class=hljs-keyword >do</span> lib
           lib.second.loc.func === :_describe
       <span class=hljs-keyword >end</span>
<span class=hljs-number >2</span>-element <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Pair</span>{<span class=hljs-built_in >Float64</span>, SnoopCompile.LocationBreaks}}:
            <span class=hljs-number >0.0017508</span> =&gt; _describe at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:<span class=hljs-number >585</span> (<span class=hljs-number >1</span> instances)
 <span class=hljs-number >0.025253789999999998</span> =&gt; _describe at /home/tim/.julia/dev/DataFrames/src/abstractdataframe/abstractdataframe.jl:<span class=hljs-number >639</span> (<span class=hljs-number >8</span> instances)</code></pre>
<p>27ms is a little better, but it&#39;s still not a lot of time; while there&#39;s every reason to hope we could improve <code>_describe</code>, we&#39;re looking for the big fish, and this clearly isn&#39;t one of them. Because the DataFrames developers are very good at their job, we have to go a long ways back, almost 40 entries, in <code>libs</code> before we get to a candidate that can be substantially improved:</p>
<pre><code class="julia hljs">julia&gt; lib
<span class=hljs-number >0.6566298570000001</span> =&gt; <span class=hljs-comment >#_vcat#124 at /home/tim/.julia/packages/DataFrames/Zx5mm/src/abstractdataframe/abstractdataframe.jl:1625 (23 instances)</span>

julia&gt; mis = collect_instances(lib.second, tinf)
<span class=hljs-number >10</span>-element <span class=hljs-built_in >Vector</span>{Core.MethodInstance}:
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s17&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s17&quot;</span>&lt;:AbstractDataFrame)
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{AbstractDataFrame})
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{T} <span class=hljs-keyword >where</span> T&lt;:AbstractDataFrame)
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{DataFrame})
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{SubDataFrame{DataFrame, DataFrames.Index, <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int64</span>}}})
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Symbol</span>, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{SubDataFrame{DataFrame, S, <span class=hljs-built_in >UnitRange</span>{<span class=hljs-built_in >Int64</span>}} <span class=hljs-keyword >where</span> S&lt;:DataFrames.AbstractIndex})
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >String</span>}, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s17&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s17&quot;</span>&lt;:AbstractDataFrame)
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >String</span>}, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{DataFrame})
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Symbol</span>}, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >AbstractVector</span>{<span class=hljs-string >var&quot;#s17&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s17&quot;</span>&lt;:AbstractDataFrame)
 MethodInstance <span class=hljs-keyword >for</span> <span class=hljs-string >var&quot;#_vcat#124&quot;</span>(::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Symbol</span>}, ::typeof(DataFrames._vcat), ::<span class=hljs-built_in >Vector</span>{DataFrame})</code></pre>
<p>This is a relatively small number &#40;10&#41; of calling <code>MethodInstance</code>s, and relatively few runtime-dispatched instances &#40;23&#41;, so this might suggest one or more steps where inference is just having a hard time figuring out a type that could be made predictable.  We extract any one of these <code>MethodInstance</code>s and fire up <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu</a> :</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> Cthulhu

julia&gt; descend(mis[<span class=hljs-number >1</span>]; iswarn=<span class=hljs-literal >true</span>, optimize=<span class=hljs-literal >false</span>)</code></pre>
<p>If you&#39;ve not used Cthulhu before, it&#39;s a wonderful tool; there&#39;s a video <a href="https://www.youtube.com/watch?v&#61;7VbXbI6OmYo">here</a> which &#40;starting at minute 7&#41; is essentially a Cthulhu tutorial.  Cthulhu will tell you, for instance, that <code>header</code> is a <code>Core.Box</code>, and in part the code <code>cols</code> is a <code>Union&#123;Vector&#123;String&#125;, Core.Box&#125;</code>.  This is typically a sign of the infamous <a href="https://github.com/JuliaLang/julia/issues/15276">Julia issue 15276</a>, and workarounds are documented <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-captured">here</a>.  Specifically, changing <a href="https://github.com/JuliaData/DataFrames.jl/blob/8645651e30785fbedca82a9f125d21d1f27a726e/src/abstractdataframe/abstractdataframe.jl#L1589">this line</a> to</p>
<pre><code class="julia hljs"><span class=hljs-keyword >let</span> header=header     <span class=hljs-comment ># julia #15276</span>
    filter!(u -&gt; !issetequal(u, header), uniqueheaders)
<span class=hljs-keyword >end</span></code></pre>
<p>fixes the first <code>Core.Box</code>, and renaming <a href="https://github.com/JuliaData/DataFrames.jl/blob/8645651e30785fbedca82a9f125d21d1f27a726e/src/abstractdataframe/abstractdataframe.jl#L1593-L1595">this <code>cols</code></a> to <code>badcols</code> fixes the second.  The only other easily-fixable case is that <a href="https://github.com/JuliaData/DataFrames.jl/blob/8645651e30785fbedca82a9f125d21d1f27a726e/src/abstractdataframe/abstractdataframe.jl#L1563">this usage</a> of <code>names</code> is not inferrable for an <code>AbstractDataFrame</code>, but changing <a href="https://github.com/JuliaData/DataFrames.jl/blob/8645651e30785fbedca82a9f125d21d1f27a726e/src/other/index.jl#L425">this line</a> to</p>
<pre><code class="julia hljs">Base.names(x::SubIndex) = string.(_names(x))::<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >String</span>}</code></pre>
<p>fixes that. All of these are quite easily discoverable via Cthulhu.</p>
<h2 id=final_results ><a href="#final_results">Final results</a></h2>
<p>Let&#39;s check and see how much of an overall improvement the changes have made:</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> DataFrames; <span class=hljs-meta >@time</span> include(<span class=hljs-string >&quot;runtests.jl&quot;</span>)
⋮
<span class=hljs-number >571.898755</span> seconds (<span class=hljs-number >1.04</span> G allocations: <span class=hljs-number >60.339</span> GiB, <span class=hljs-number >3.40</span>% gc time, <span class=hljs-number >96.14</span>% compilation time)</code></pre>
<p>Compared to where we started &#40;almost 621s&#41;, this shaves almost a minute off the time to run the test suite. Even the second run is faster now:</p>
<pre><code class="julia hljs">julia&gt; <span class=hljs-meta >@time</span> include(<span class=hljs-string >&quot;runtests.jl&quot;</span>)
⋮
<span class=hljs-number >196.870680</span> seconds (<span class=hljs-number >276.72</span> M allocations: <span class=hljs-number >16.498</span> GiB, <span class=hljs-number >2.65</span>% gc time, <span class=hljs-number >87.12</span>% compilation time)</code></pre>
<p>which is 40s less than the original &#40;a savings of approximately 16&#37;&#41;.</p>
<p>This is certainly not everything we <em>could</em> do on the package, but it&#39;s enough to illustrate some of the main strategies for improving latency.  Someone who understood the internals well might reject these changes, and instead make them at higher levels and obtain even greater benefits. But this should illustrate the different tools, considerations, and techniques for improving latency in packages.</p>
<h2 id=conclusions ><a href="#conclusions">Conclusions</a></h2>
<p>Latency &#40;&quot;first time to plot&quot;&#41; is one of the most common complaints for users of Julia. Using the soon-to-be-released Julia 1.6 and new capabilities of the SnoopCompile package, it&#39;s easier than ever to diagnose and fix sources of latency.  Here, we&#39;ve emphasized reducing specialization, simplifying methods that need many specializations, and fixing inference failures as techniques for reducing latency.  We&#39;ve not strongly emphasized precompilation &#40;that has existed for quite a while now&#41;, but it should not be ignored by developers looking to reduce latency.  Indeed, the strategies we explored here should extract more benefit from precompilation: by fixing inference problems we can precompile more code, and by reducing type-diversity some portions of code that were not practical to precompile previously may suddenly become worthy of precompilation.  These changes can immediately improve the user experience.  Moreover, if a future version of Julia delivers native-code precompilation, these same changes will allow packages to exploit it to its fullest.  These new tools, arriving in Julia 1.6, give a far richer understanding of how a large code base is viewed from the standpoint of the compiler.</p>
<p> <a name=footnote1 ></a>[†]  Technically, <code>@nospecialize</code> controls code-generation rather than inference, although it indirectly affects inference by preventing specialization on call sites.  Running inference on methods annotated <code>@nospecialize</code> allows callers, who often do know the argument types, to infer the return type&#40;s&#41; of the method.</p>
</div><br><br>


    
    
        


    

    <footer class="container-fluid footer-copy">
  <div class=container >
    <div class="row footrow">
      <ul>
        <li><a href="/previews/PR1093/project">About</a>
        <li><a href="/previews/PR1093/about/help">Get Help</a>
        <li><a href="/previews/PR1093/blog/2019/02/julia-entities/">Governance</a>
        <li><a href="/previews/PR1093/research/#publications">Publications</a>
        <li><a href="/previews/PR1093/research/#sponsors">Sponsors</a>
      </ul>
      <ul>
        <li><a href="/previews/PR1093/downloads/">Downloads</a>
        <li><a href="/previews/PR1093/downloads/">All Releases</a>
        <li><a href="https://github.com/JuliaLang/julia">Source Code</a>
        <li><a href="/previews/PR1093/downloads/#current_stable_release">Current Stable Release</a>
        <li><a href="/previews/PR1093/downloads/#long_term_support_release">Longterm Support Release</a>
        <li><a href="https://status.julialang.org/">PkgServer Status</a>
      </ul>
      <ul>
        <li><a href="https://docs.julialang.org/en/v1/">Documentation</a>
        <li><a href="https://juliaacademy.com">JuliaAcademy</a>
        <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a>
        <li><a href="/previews/PR1093/learning/getting-started/">Getting Started</a>
        <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a>
        <li><a href="/previews/PR1093/learning/books">Books</a>
      </ul>
      <ul>
        <li><a href="/previews/PR1093/community/">Community</a>
        <li><a href="/previews/PR1093/community/standards/">Code of Conduct</a>
        <li><a href="/previews/PR1093/diversity/">Diversity</a>
        <li><a href="https://juliacon.org">JuliaCon</a>
        <li><a href="/previews/PR1093/community/#julia_user_and_developer_survey">User/Developer Survey</a>
        <li><a href="/previews/PR1093/shop/">Shop Merchandise</a>
      </ul>
      <ul>
        <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a>
        <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a>
        <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a>
        <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a>
        <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">Good First Issue</a>
        <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a>
      </ul>
    </div>
    <div id=footer-bottom  class=row >
      <div class="col-md-10 py-2">
        <p>Built with <a href="https://franklinjl.org">Franklin.jl</a> and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p>
        <p>©2020 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.
      </div>
      <div class="col-md-2 py-2">
        <span class=float-sm-right >
          <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a>
        </span>
      </div>
    </div>
  </div>
</footer>

<script src="/previews/PR1093/libs/jquery/jquery.min.js"></script>
<script src="/previews/PR1093/libs/bootstrap/bootstrap.min.js"></script>