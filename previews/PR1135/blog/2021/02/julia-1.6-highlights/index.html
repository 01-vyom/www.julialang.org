<!doctype html> <html lang=en > <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv=x-ua-compatible  content="ie=edge"> <meta name=author  content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al."> <meta name=description  content="The official website for the Julia Language. Julia is a language that is fast, dynamic, easy to use, and open source. Click here to learn more."> <meta name=robots  content="max-image-preview:large"> <meta name="twitter:site:id" content=1237720952 > <meta name=google-site-verification  content=9VDSjBtchQj6PQYIVwugTPY7pVCfLYgvkXiRHjc_Bzw  /> <link rel=icon  href="/previews/PR1135/assets/infra/julia.ico"> <link rel=stylesheet  href="/previews/PR1135/libs/highlight/github.min.css"> <link rel=stylesheet  href="/previews/PR1135/libs/bootstrap/bootstrap.min.css"> <link rel=stylesheet  href="/previews/PR1135/css/app.css"> <link rel=stylesheet  href="/previews/PR1135/css/franklin.css"> <link rel=stylesheet  href="/previews/PR1135/css/fonts.css"> <link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel=stylesheet > <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel=stylesheet > <script async defer src="/previews/PR1135/libs/buttons.js"></script> <!-- --> <script type="application/javascript"> var doNotTrack = false; if (!doNotTrack) { window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date; ga('create', 'UA-28835595-1', 'auto'); ga('send', 'pageview'); } </script> <script async src='https://www.google-analytics.com/analytics.js'></script> <title>Julia 1.6 Highlights</title> <style> .container ul li p {margin-bottom: 0;} </style> <style> .main { font-family: Georgia; } .main pre { margin-left: auto; margin-right: auto; } .main { width: 100%; font-size: 100%; } .main code { font-size: 90%; } .main pre code { font-size: 90%; } @media (min-width: 940px) { .main { width: 800px; } .container.blog-title { width: 800px;} } </style> <meta property="og:title" content="Julia 1.6 Highlights"> <meta property="og:description" content="Some highlights of the Julia 1.6 release."> <meta property="og:image" content="/assets/images/julia-open-graph.png"> <div class="container py-3 py-lg-0"> <nav class="navbar navbar-expand-lg navbar-light bg-light" id=main-menu > <a class=navbar-brand  href="/previews/PR1135/"> <img src="/previews/PR1135/assets/infra/logo.svg" alt="JuliaLang Logo"> </a> <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mx-auto"> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/downloads/">Download</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="https://docs.julialang.org">Documentation</a> <li class="nav-item active flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/blog/">Blog</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/community/">Community</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/learning/">Learn</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/research/">Research</a> <li class="nav-item flex-md-fill text-md-center"> <a class=nav-link  href="/previews/PR1135/jsoc/">JSoC</a> </ul> <span class=navbar-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </nav> </div> <br><br> <div class="container blog-title"> <h1>Julia 1.6 Highlights <a type="application/rss+xml" href="https://julialang.org/feed.xml"> <i class="fa fa-rss-square rss-icon"></i> </a> </h1> <h3> <span style="font-weight: lighter;"> 28 February 2021 </span> | <span style="font-weight: bold;"></span> <span style="font-weight: bold;">Jeff Bezanson, Ian Butterworth, Nathan Daly, Keno Fischer, Tim Holy, Stefan Karpinski </span> </h3> </div> <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/blog/2021/02/julia-1.6-highlights.md" title="Edit this page on GitHub" class=edit-float > </a> <div class="container main"><p>Julia version 1.6 has been released. Most Julia releases are timed and hence not planned around specific features, but this release was an exception since it is likely to become the next long-term support &#40;LTS&#41; release of Julia. Because of this we took extra time developing the release to make sure that features that are needed for the future health of the ecosystem made it into the release. The final decision about whether Julia 1.6 will become the new LTS will not be made until around the time that the 1.7 release enters stabilization, at which point we&#39;ll have a much better sense of how good of a release it was — like baked goods, some releases just come out better than others and you can&#39;t always tell until after they are baked and eaten. The full list of changes can be found in the <a href="https://github.com/JuliaLang/julia/blob/release-1.6/NEWS.md">NEWS file</a>, but here we&#39;ll give a more in depth overview of some of the release highlights.</p> <div class=franklin-toc ><ol><li><a href="#parallel_precompilation">Parallel precompilation</a><li><a href="#compile_time_percentage">Compile time percentage</a><li><a href="#eliminating_needless_recompilation">Eliminating needless recompilation</a><li><a href="#compiler_latency_reduction">Compiler latency reduction</a><li><a href="#tooling_to_help_optimize_packages_for_latency">Tooling to help optimize packages for latency</a><li><a href="#binary_loading_speedups">Binary loading speedups</a><li><a href="#downloads_networkingoptions">Downloads &amp; NetworkingOptions</a><li><a href="#ci_robustness">CI Robustness</a><li><a href="#conclusion">Conclusion</a></ol></div> <h2 id=parallel_precompilation ><a href="#parallel_precompilation">Parallel precompilation</a></h2> <p><em>Ian Butterworth</em></p> <p>Executing all of the statements in a module often involves compiling a large amount of code, so Julia creates precompiled caches of the module to reduce this time. In 1.6, this package precompilation is faster and happens before you leave <code>pkg&gt;</code> mode. Until now, precompilation took place solely as a single-processed sequence, precompiling dependencies one-by-one when needed during the linear code loading process when a package is <code>using</code>/<code>import</code>-ed for the first time.</p> <p>The olden days of &lt;&#61; 1.5:</p> <pre><code class=language-julia-repl >&#40;v1.5&#41; pkg&gt; add DifferentialEquations
...
julia&gt; @time using DifferentialEquations
&#91; Info: Precompiling DifferentialEquations &#91;0c46a032-eb83-5123-abaf-570d42b7fbaa&#93;
  474.288251 seconds …</code></pre> <p>In 1.6, <code>pkg&gt;</code> mode gains a heavily parallelized precompile operation that is auto-invoked after package actions, to keep the active environment ready to load.</p> <pre><code class=language-julia-repl >&#40;v1.6&#41; pkg&gt; add DifferentialEquations
...
Precompiling project...
  Progress &#91;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&#61;&gt;&#93;  112/112
112 dependencies successfully precompiled in 72 seconds

julia&gt; @time using DifferentialEquations
  4.995477 seconds …</code></pre> <p>Whereas the previous code loading precompilation process took ~8 minutes to precompile and load without indicating progress while doing so, the new mechanism took a little over 1 minute to precompile while showing progress through the dependencies, then the first time the package is loaded it happens at full speed. The new parallel precompilation process takes a depth-first approach of working through the dependency tree in the manifest, first precompiling the packages with no dependencies and working upward to the packages listed in the environment’s <code>Project.toml</code>, allowing multiple packages to be precompiled at the same time. The operation is multi-processed, as opposed to multi-threaded, so is not limited by Julia’s thread count. By default, Julia will spawn a maximum CPU-balanced load of package precompile jobs at once based on the number of CPU cores. Errors during precompilation will only throw for packages listed in the Project to allow for dependencies that may be listed in manifests but not loaded, and the auto precompilation process will remember if a package has errored within the given environment and will not retry until it changes. Auto-precompilation can be gracefully interrupted with a <code>ctrl-c</code> and disabled by setting the environment variable <code>JULIA_PKG_PRECOMPILE_AUTO&#61;0</code>.</p> <script id=asciicast-381203  src="https://asciinema.org/a/381203.js" data-rows=25  data-cols=104  async></script> <p>For packages that are being developed, given that their code will be changed by other mechanisms than Pkg, this new workflow won’t automatically avoid encountering the standard code-load time precompilation. However non-dev-ed dependencies of those packages will be kept ready to load, so top-level precompilation at load time should remain lower for dev-ed packages.</p> <h2 id=compile_time_percentage ><a href="#compile_time_percentage">Compile time percentage</a></h2> <p><em>Ian Butterworth</em></p> <p>A small change that should help understanding of one of Julia’s quirks for newcomers is that the timing macro <code>@time</code> and its verbose friend <code>@timev</code> now report if any of the reported time has been spent on compilation.<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup></p> <pre><code class=language-julia-repl >julia&gt; x &#61; rand&#40;10,10&#41;;

julia&gt; @time x * x;
  0.540600 seconds &#40;2.35 M allocations: 126.526 MiB, 4.43&#37; gc time, 99.94&#37; compilation time&#41;

julia&gt; @time x * x;
  0.000010 seconds &#40;1 allocation: 896 bytes&#41;</code></pre> <p>Given Julia’s Just In Time &#40;JIT&#41; / Just Ahead Of Time &#40;JAOT&#41; compilation, the first time code is run the compilation overhead is often substantial, with big speed improvements seen in subsequent calls. This change highlights that behavior, serving as both a reminder and a tool for rooting out unwanted compilation effort i.e. over-specialized code</p> <p><table class=fndef  id="fndef:1"> <tr> <td class=fndef-backref ><a href="#fnref:1">[1]</a> <td class=fndef-content >Note that the time reported by <code>@time</code> does not include time spent in </table> julia’s code interpreter, which may be significant.</p> <h2 id=eliminating_needless_recompilation ><a href="#eliminating_needless_recompilation">Eliminating needless recompilation</a></h2> <p><em>Tim Holy</em></p> <p>One of Julia’s most powerful features is its extensibility: you can add new methods to previously-defined functions, and use previously-defined methods on new types. Sometimes, these new entities force Julia to recompile code to account for changes in dispatch. This happens in two steps: first, “outdated” code gets <em>invalidated</em>, marking it as unsuitable for use; second, as needed the code is again compiled from scratch taking account of the new methods and types.</p> <p>Earlier versions of Julia were somewhat conservative, and invalidated old code in some circumstances where there was no actual change in dispatch. Moreover, there were many places where Julia and its standard libraries were written in a way that defeated Julia’s type-inference. Because the compiler sometimes had to invalidate code just because a new method <em>might</em> apply, any uncertainty about types magnifies the risk and frequency of invalidation. In older versions of Julia, the combination of these effects made invalidation widespread: just loading certain packages led to invalidation of up to 10&#37; of Julia’s precompiled code. The delay for recompilation could sometimes make interactive sessions feel sluggish. When invalidation occurred in Julia’s package-loading code, it also delayed loading of the next package, contributing to long waits for using SomePkg when SomePkg depends on other packages.</p> <p>In 1.6, the scheme for invalidating old code has been made more accurate and selective. Moreover, Julia and its standard libraries received a thorough makeover to help type inference arrive at a concrete answer more often. The result is a leaner, faster Julia that is far more impervious to method invalidation, and feels considerably more responsive and nimble in interactive sessions. Related blog post: <a href="https://julialang.org/blog/2020/08/invalidations/">https://julialang.org/blog/2020/08/invalidations/</a>.</p> <h2 id=compiler_latency_reduction ><a href="#compiler_latency_reduction">Compiler latency reduction</a></h2> <p><em>Jeff Bezanson</em></p> <h2 id=tooling_to_help_optimize_packages_for_latency ><a href="#tooling_to_help_optimize_packages_for_latency">Tooling to help optimize packages for latency</a></h2> <p><em>Nathan Daly &amp; Tim Holy</em></p> <p>Julia 1.6, in conjunction with SnoopCompile v2.2.0 or higher, features new tools for compiler introspection, especially &#40;but not exclusively&#41; for type inference. Developers can use the new tools to profile type inference and determine how particular package implementation choices interact with compilation time. Early adopters have used these tools to eliminate anywhere from a few percent to the large majority of first-use latency.</p> <ul> <li><p>Related blog post: <a href="https://julialang.org/blog/2021/01/precompile_tutorial/">https://julialang.org/blog/2021/01/precompile_tutorial/</a></p> <li><p>Documentation: <a href="https://timholy.github.io/SnoopCompile.jl/stable/">https://timholy.github.io/SnoopCompile.jl/stable/</a></p> </ul> <h2 id=binary_loading_speedups ><a href="#binary_loading_speedups">Binary loading speedups</a></h2> <p><em>Elliot Saba &amp; Mosè Giordano</em></p> <p>Providing reliable, portable binaries to packages is a challenge that all packaging environments must face, and while Julia&#39;s strategy has always been to prioritize reliability and reproducibility over all other concerns, in the past it has come at a cost. Our solution to the problems of reliability and reproducibility was to more fully isolate installed binaries and cross-compile them ourselves using the <a href="https://github.com/JuliaPackaging/BinaryBuilder.jl"><code>BinaryBuilder.jl</code></a> framework. Libraries built from <code>BinaryBuilder.jl</code> are most often used through so-called JLL packages which provide a standardized API that Julia packages can use to access the provided binaries. This ease of use and reliability of installation resulted in <em>vastly</em> increased load times as compared to the bad old days when Julia packages would blindly <code>dlopen&#40;&#41;</code> libraries and load whatever libraries happened to be sitting on the library search path. To illustrate the issue, in Julia 1.4, loading the GTK&#43;3 stack required <strong>7 seconds</strong> when it used to take around <strong>500ms</strong> on the same machine. Through many months of hard work and careful investigation, we are pleased to report that the same stack of libraries now takes less than <strong>200ms</strong> to load when using Julia v1.6 on the same machine.</p> <p>The cause of this slowdown was multi-faceted and spread across many different layers of the Julia ecosystem. Part of the issue was general compiler latency, which has been a focus of the compiler team for some time now, as evidenced by Jeff&#39;s post in this blogpost. Another major piece though was general overhead incurred by having so many small JLL packages providing bindings; there was significant overhead in the loading of each package. In particular, there was code inferrence, code generation and datastructure loading that needed to be eliminated if the JLL packages were to be lightweight enough to not affect overall load times. In our experiments, we found that one of the largest sources of package load times was in the deserialization of backedge information, the links from functions in <code>Base</code> back to our packages that would cause our functions to be recompiled if there was an invalidation effecting that <code>Base</code> function. As counter-intuitive as it may seem, simply using a large number of functions from <code>Base</code> can very quickly balloon the precompilation cache files for your package, causing an increase in loading time&#33; While the increase itself is small, &#40;<code>3-10ms</code> at the worst&#41; when you are loading many dozens of JLL packages, this adds up quickly.</p> <p>Our work to slim JLL packages down resulted in the creation of a new package, <a href="https://github.com/JuliaPackaging/JLLWrappers.jl"><code>JLLWrappers.jl</code></a>. This package provides macros that auto-generate the bindings necessary for a JLL package, and do so by using the minimum number of functions and datastructures possible. By limiting the number of backedges and datastructures, as well as centralizing the template pieces of code that each JLL package uses, we are able to not only vastly improve load times, but improve compile times as well&#33; As an added bonus, improvements to JLL package APIs can now be made directly in <code>JLLWappers.jl</code> without needing to re-deploy hundreds of JLLs. Because these JLL packages only define a thin wrapper around simple, lightweight functions that load libraries and return paths and such, they do not benefit from the heavy optimization that most Julia code undergoes. One final piece of the optimization puzzle was therefore to disable optimizations and use the new <a href="https://julialang.org/blog/2020/08/julia-1.5-highlights/#per-module_optimization_levels">per-module optimization levels</a> functionality to reduce the amount of time spent generating a very small amount of code, saving precious seconds.</p> <div> <a href="https://plotly.com/~staticfloat/76/?share_key=OO3EAHlACh6ayQYMKURbX0" target=_blank  title="Plot 76" style="display: block; text-align: center;"><img src="https://plotly.com/~staticfloat/76.png?share_key=OO3EAHlACh6ayQYMKURbX0" alt="Plot 76" style="max-width: 100%;width: 600px;" width=600  onerror="this.onerror=null;this.src='https://plotly.com/404.png';" /></a> <script data-plotly="staticfloat:76" sharekey-plotly=OO3EAHlACh6ayQYMKURbX0  src="https://plotly.com/embed.js" async></script> </div> <p>The interplay between compiler improvements and the benefits that <code>JLLWrappers</code> affords were <a href="https://github.com/JuliaGraphics/Gtk.jl/issues/466#issuecomment-716058685">well-recorded</a> during the development process, and showcase a speedup of load times for the original, non-JLLWrapperized <code>GTK3_jll</code> packge from its peak at <code>6.73</code> seconds on Julia v1.4 down to <code>2.34</code> seconds on Julia v1.6, purely from compiler improvements. If you haven&#39;t thanked your local compiler team today, you probably should. Using the slimmed-down JLLWrappers implementation of all relevant JLLWrappers packages results in a further lowering of load time down to a blistering <code>140ms</code>. End-to-end, this means that this work effected a roughly <strong><code>50x</code> speedup</strong> in load times for large trees of binary artifacts. While there are some minor improvements for lazy loading of shared libraries and such in the pipeline, we are confident that this work will provide a strong foundation for Julia&#39;s binary packaging story for the forseeable future.</p> <h2 id=downloads_networkingoptions ><a href="#downloads_networkingoptions">Downloads &amp; NetworkingOptions</a></h2> <p><em>Stefan Karpinski</em></p> <p>In previous releases, when you download something in Julia, either directly, using the <code>Base.download</code> function, or indirectly when using <code>Pkg</code>, the actual downloading was done by some external process—whichever one of <code>curl</code>, <code>wget</code>, <code>fetch</code> or <code>PowerShell</code> happened to be available on your system. The fact that this frankendownload feature worked at all was something of a miracle, that only worked due to much fussy command-line-option finessing of over the years. And while this did mostly work, there were some major drawbacks to this approach.</p> <ol> <li><p><strong>It’s slow.</strong> Starting a new process for each download is expensive; but worse, those processes can’t share TCP connections or reuse already negotiated TLS connections, so every download needs to do the while TCP SYN/ACK song and dance and then also do the TLS secret handshake, all of which which takes a lot of time.</p> <li><p><strong>It’s inconsistent.</strong> Since the exact way things got downloaded depended on what happens to be installed on your system, download behavior was terribly inconsistent. Downloads that work on one system might not work on another one. Moreover, any issues someone might have, inevitably end up out of scope for Julia to fix — the typical answer is &quot;fix your system <code>curl</code>/<code>wget</code>/whatever,&quot; which is not a very satifactory solution for someone using Julia who just wants to be able to download things.</p> <li><p><strong>It’s inflexible.</strong> The core requirements of downloading something are simple: URL in, file out. But maybe you need to pass some custom headers with the request. Or maybe you need to see what headers were returned. Often you want to display progress for large downloads. Some download commands have options for some of these, but we can only support options that are supported by all download methods, which has forced downloads to be pretty inflexible.</p> </ol> <p>In Julia 1.6 all downloading is done with <code>libcurl-7.73.0</code> via the new <code>Downloads.jl</code> standard library. Downloading is done in-process and TCP&#43;TLS connections are shared and reused. If the server supports HTTP/2, multiple requests to that server can even be multiplexed onto the same HTTPS connections. All of this means that downloads are much faster.</p> <p>Since all Julia users now use the same method to download things, if it works on one system, it is much more likely to work everywhere. No more broken downloads just because the system curl happens to be really old. And <code>libcurl</code> is highly configurable: we can pass custom headers with requests, see what headers were included with the response, and get download progress — all in the same way everywhere.</p> <p>As part of reworking downloads, we have switched to using the built-in TLS stack on macOS and Windows, which allows downloads to use the built-in mechanism for verifying the identity of TLS servers via the system’s collection of certificate authority root certificates &#40;“CA roots”, for short&#41;. On Linux and FreeBSD, we now also look in the standard locations for a PEM file with CA root certificates. The advantage of using the system CA root certificates is that most systems will automatically keep these CA roots up-to-date and on Windows and macOS the OS will check for revoked certificates when performing certificate verification &#40;Linux doesn&#39;t have standard way to do this&#41;. Julia itself still ships with a reasonably up-to-date bundle of CA roots, but we no longer use it by default unless system CA roots cannot be found.</p> <p>Using the system CA roots already means that it’s much more likely that Julia will “just work” from behind firewalls. Many institutional firewalls will man-in-the-middle &#40;MITM&#41; your outgoing HTTPS connections and present a forged HTTPS certificate for the server to your client connection. In order for this not to set off security alarms on your client, they will typically add a private CA root certificate to the user&#39;s system so that your browser will accept the firewall’s forged certificate. Since Julia now uses the system’s CA roots, it respects any private CA roots that have been added there.</p> <p>If this doesn’t work for some reason, Julia 1.6 also introduces the <code>NetworkOptions.jl</code> stdlib: this package acts as a central place for network configuration options that can be controlled by various environment variables and which are used to modify the behavior of networking libraries like <code>libcurl</code> and <code>libgit2</code> in a consistent way. For example, if you want to turn off HTTPS host verification entirely, you can do <code>export JULIA_SSL_NO_VERIFY_HOSTS&#61;&quot;**&quot;</code> in your shell and both the Downloads and LibGit2 packages will not perform host verification when downloading over HTTPS. There are various other options available in NetworkOptions, including:</p> <ul> <li><p><code>JULIA_SSL_CA_ROOTS_PATH</code> to provide a custom PEM file of CA roots</p> <li><p><code>SSH_KNOWN_HOSTS_FILES</code> to use non-standard locations for SSH known hosts</p> <li><p><code>JULIA_*_VERIFY_HOSTS</code> variables for fine-grained control over which hosts should or shouldn’t be verified over various transports, including TLS and SSH</p> </ul> <p>These options are now consistently respected across all network-facing code that ships with Julia itself and we will be working with package developers to encourage them to use <code>NetworkOptions</code> for configuration of libraries such as mbedtls and others. This will allow consistent configuration of networking options across the entire Julia ecosystem.</p> <h2 id=ci_robustness ><a href="#ci_robustness">CI Robustness</a></h2> <p><em>Jeff Bezanson &amp; Keno Fischer</em></p> <p>This release cycle we spent quite a bit of time paying down technical debt in the form of intermittent test failures in our continuous integration &#40;CI&#41; process. Like all responsible software projects these days, we run our full build and test suite for every commit and for every proposed change. If the tests fail, you stop the presses until the problem is fixed — either by reverting a change, committing a new fix, or revising a proposed patch until it passes. Given this simple policy, it’s difficult to see how a project could be ambushed by persistent test failures. And yet that’s exactly what happened to us: over time, we ended up in a state where a high percentage of test runs failed, usually with just a single obscure test case failing.</p> <p>Several factors contributed to this predicament. First, the base Julia test suite is quite large and covers a wide range of functionality, from parsing and compiling to linear algebra, package management, sockets, handling file system events, and more. With that much surface area, we were likely to end up with a handful of rare bugs, or failures due to overly-fragile tests. We run easily over a hundred builds per day, so even failure rates of 0.1&#37; would appear often enough to cause problems. Timing-sensitive tests are a classic example, e.g. testing that a one-second timeout indeed happens after approximately one second. On hosted VMs in particular, timing can be far more variable than what you would ever see on dedicated hardware. A one-second timeout can, unfortunately, take more than 60 seconds on a heavily loaded VM.</p> <h2 id=conclusion ><a href="#conclusion">Conclusion</a></h2> </div><br><br> <script src="/previews/PR1135/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script> <footer class="container-fluid footer-copy"> <div class=container > <div class="row footrow"> <ul> <li><a href="/previews/PR1135/project">About</a> <li><a href="/previews/PR1135/about/help">Get Help</a> <li><a href="/previews/PR1135/blog/2019/02/julia-entities/">Governance</a> <li><a href="/previews/PR1135/research/#publications">Publications</a> <li><a href="/previews/PR1135/research/#sponsors">Sponsors</a> </ul> <ul> <li><a href="/previews/PR1135/downloads/">Downloads</a> <li><a href="/previews/PR1135/downloads/">All Releases</a> <li><a href="https://github.com/JuliaLang/julia">Source Code</a> <li><a href="/previews/PR1135/downloads/#current_stable_release">Current Stable Release</a> <li><a href="/previews/PR1135/downloads/#long_term_support_release">Longterm Support Release</a> <li><a href="https://status.julialang.org/">PkgServer Status</a> </ul> <ul> <li><a href="https://docs.julialang.org/en/v1/">Documentation</a> <li><a href="https://juliaacademy.com">JuliaAcademy</a> <li><a href="https://www.youtube.com/user/JuliaLanguage">YouTube</a> <li><a href="/previews/PR1135/learning/getting-started/">Getting Started</a> <li><a href="https://docs.julialang.org/en/v1/manual/faq/">FAQ</a> <li><a href="/previews/PR1135/learning/books">Books</a> </ul> <ul> <li><a href="/previews/PR1135/community/">Community</a> <li><a href="/previews/PR1135/community/standards/">Code of Conduct</a> <li><a href="/previews/PR1135/diversity/">Diversity</a> <li><a href="https://juliacon.org">JuliaCon</a> <li><a href="/previews/PR1135/community/#julia_user_and_developer_survey">User/Developer Survey</a> <li><a href="/previews/PR1135/shop/">Shop Merchandise</a> </ul> <ul> <li><a href="https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md">Contributing</a> <li><a href="https://github.com/JuliaLang/julia/issues">Issue Tracker</a> <li><a href="https://github.com/JuliaLang/julia/security/policy">Report a Security Issue</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22help+wanted%22">Help Wanted Issues</a> <li><a href="https://github.com/issues?q=is%3Aopen+is%3Aissue+language%3AJulia+label%3A%22good+first+issue%22+">Good First Issue</a> <li><a href="https://docs.julialang.org/en/v1/devdocs/reflection/">Dev Docs</a> </ul> </div> <div id=footer-bottom  class=row > <div class="col-md-10 py-2"> <p>Built with <a href="https://franklinjl.org">Franklin.jl</a> and the <a href="https://julialang.org">Julia Programming Language</a>. We thank <a href="https://www.fastly.com">Fastly</a> for their generous infrastructure support.</p> <p>©2020 JuliaLang.org <a href="https://github.com/JuliaLang/www.julialang.org/graphs/contributors">contributors</a>. The content on this website is made available under the <a href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>. </div> <div class="col-md-2 py-2"> <span class=float-sm-right > <a class=github-button  href="https://github.com/sponsors/julialang" data-icon=octicon-heart  data-size=large  aria-label="Sponsor @julialang on GitHub">Sponsor</a> </span> </div> </div> </div> </footer> <script src="/previews/PR1135/libs/jquery/jquery.min.js"></script> <script src="/previews/PR1135/libs/bootstrap/bootstrap.min.js"></script>